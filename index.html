<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>LIMの博客</title><meta name="author" content="LIM"><meta name="copyright" content="LIM"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta property="og:type" content="website">
<meta property="og:title" content="LIMの博客">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="LIMの博客">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/3534643.png">
<meta property="article:author" content="LIM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/3534643.png"><link rel="shortcut icon" href="/img/letter-l.png"><link rel="canonical" href="http://example.com/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'LIMの博客',
  isPost: false,
  isHome: true,
  isHighlightShrink: false,
  isToc: false,
  postUpdate: '2023-02-28 10:24:39'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/background.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/3534643.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 时间轴</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="page" id="body-wrap"><header class="full_page" id="page-header" style="background-image: url('/img/wallhaven-d68mp3.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="LIMの博客"><span class="site-name">LIMの博客</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 时间轴</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="site-info"><h1 id="site-title">LIMの博客</h1><div id="site-subtitle"><span id="subtitle"></span></div><div id="site_social_icons"><a class="social-icon" href="https://github.com/Scorpios7" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div id="scroll-down"><i class="fas fa-angle-down scroll-down-effects"></i></div></header><main class="layout" id="content-inner"><div class="recent-posts" id="recent-posts"><div class="recent-post-item"><div class="post_cover left"><a href="/post/32178238.html" title="认识JVM"><img class="post-bg" src="/img/wallhaven-vg69p3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="认识JVM"></a></div><div class="recent-post-info"><a class="article-title" href="/post/32178238.html" title="认识JVM">认识JVM</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2023-02-28T01:54:40.000Z" title="发表于 2023-02-28 09:54:40">2023-02-28</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a></span></div><div class="content">文章内容来自https://juejin.cn/post/6844904048013869064
JVM的基本介绍JVM 是 Java Virtual Machine 的缩写，它是一个虚构出来的计算机，一种规范。通过在实际的计算机上仿真模拟各类计算机功能实现···
好，其实抛开这么专业的句子不说，就知道JVM其实就类似于一台小电脑运行在windows或者linux这些操作系统环境下即可。它直接和操作系统进行交互，与硬件不直接交互，可操作系统可以帮我们完成和硬件进行交互的工作。


Java文件是如何被运行的比如我们现在写了一个 HelloWorld.java 好了，那这个 HelloWorld.java 抛开所有东西不谈，那是不是就类似于一个文本文件，只是这个文本文件它写的都是英文，而且有一定的缩进而已。
那我们的 JVM 是不认识文本文件的，所以它需要一个 编译 ，让其成为一个它会读二进制文件的 HelloWorld.class 
类加载器

方法区方法区 是用于存放类似于元数据信息方面的数据的，比如类信息，常量，静态变量，编译后代码···等
类加载器将 .class 文件搬过来就是 ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/post/4e62fa9c.html" title="Redis可持久化机制"><img class="post-bg" src="/img/wallhaven-zxyy5w.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis可持久化机制"></a></div><div class="recent-post-info"><a class="article-title" href="/post/4e62fa9c.html" title="Redis可持久化机制">Redis可持久化机制</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2023-02-26T12:57:19.000Z" title="发表于 2023-02-26 20:57:19">2023-02-26</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a></span></div><div class="content">AOF持久化AOF 日志试想一下，如果 Redis 每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里，然后重启 Redis 的时候，先去读取这个文件里的命令，并且执行它，这不就相当于恢复了缓存数据了吗？


这种保存写操作命令到日志的持久化方式，就是 Redis 里的 AOF(*Append Only File*) 持久化功能，注意只会记录写操作命令，读操作命令是不会被记录的，因为没意义。
在 Redis 中 AOF 持久化功能默认是不开启的，需要我们修改 redis.conf 配置文件中的以下参数：


AOF 日志文件其实就是普通的文本，我们可以通过 cat 命令查看里面的内容，不过里面的内容如果不知道一定的规则的话，可能会看不懂。
这里以「set name xiaolin」命令作为例子，Redis 执行了这条命令后，记录在 AOF 日志里的内容如下图：


Redis 是先执行写操作命令后，才将该命令记录到 AOF 日志里的，这么做有两个好处。
第一个好处，避免额外的检查开销。
因为如果先将写操作命令记录到 AOF 日志里，再执行该命令的话，如果当前的命令语法有问题， ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/post/d2f8097a.html" title="Redis数据类型详解"><img class="post-bg" src="/img/wallhaven-x8kkd3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis数据类型详解"></a></div><div class="recent-post-info"><a class="article-title" href="/post/d2f8097a.html" title="Redis数据类型详解">Redis数据类型详解</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2023-02-26T12:32:06.000Z" title="发表于 2023-02-26 20:32:06">2023-02-26</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a></span></div><div class="content">Redis 提供了丰富的数据类型，常见的有五种：String（字符串），Hash（哈希），List（列表），Set（集合）、Zset（有序集合）。
随着 Redis 版本的更新，后面又支持了四种数据类型： BitMap（2.2 版新增）、HyperLogLog（2.8 版新增）、GEO（3.2 版新增）、Stream（5.0 版新增）
Redis在线环境：https://try.redis.io/
String介绍String 是最基本的 key-value 结构，key 是唯一标识，value 是具体的值，value其实不仅是字符串， 也可以是数字（整数或浮点数），value 最多可以容纳的数据长度是 512M。


内部实现String 类型的底层的数据结构实现主要是 int 和 SDS（简单动态字符串）。
常用指令普通字符串的基本操作：
123456789101112131415# 设置 key-value 类型的值&gt; SET name linOK# 根据 key 获得对应的 value&gt; GET name&quot;lin&quot;# 判断某个 key 是否存在& ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/post/fd42e092.html" title="什么是消息队列"><img class="post-bg" src="/img/wallhaven-yxm6z7.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="什么是消息队列"></a></div><div class="recent-post-info"><a class="article-title" href="/post/fd42e092.html" title="什么是消息队列">什么是消息队列</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2023-02-26T07:28:28.000Z" title="发表于 2023-02-26 15:28:28">2023-02-26</time></span></div><div class="content">文章内容来自https://juejin.cn/post/6844903817348136968
什么是消息队列消息队列：MQ(Message Queue)
消息队列可以简单理解为：把要传输的数据放在队列中。


科普：

把数据放到消息队列叫做生产者
从消息队列里边取数据叫做消费者

为什么要用消息队列？为什么要用消息队列，也就是在问：用了消息队列有什么好处。我们看看以下的场景
解耦现在我有一个系统A，系统A可以产生一个userId


然后，现在有系统B和系统C都需要这个userId去做相关的操作


写成伪代码可能是这样的：
1234567891011121314151617public class SystemA &#123;    // 系统B和系统C的依赖    SystemB systemB = new SystemB();    SystemC systemC = new SystemC();    // 系统A独有的数据userId    private String userId = &quot;Java3y&quot;;    public void doSome ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/post/1f34c3f3.html" title="Redis三种常用的缓存读写策略"><img class="post-bg" src="/img/wallhaven-r2o1w1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis三种常用的缓存读写策略"></a></div><div class="recent-post-info"><a class="article-title" href="/post/1f34c3f3.html" title="Redis三种常用的缓存读写策略">Redis三种常用的缓存读写策略</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2023-02-25T12:57:05.000Z" title="发表于 2023-02-25 20:57:05">2023-02-25</time></span></div><div class="content">Redis三种常用的缓存读写策略Redis有三种读写策略分别是：旁路缓存模式策略、读写穿透策略、异步缓存写入策略。
这三种缓存读写策略各有优势，不存在最佳，需要我们根据实际的业务场景选择最合适的。
Cache Aside Pattern（旁路缓存模式）Cache Aside Pattern 是我们平时使用比较多的一个缓存读写模式，比较适合读请求比较多的场景。
Cache Aside Pattern 中服务端需要同时维系 db 和 cache，并且是以 db 的结果为准。
下面我们来看一下这个策略模式下的缓存读写步骤。
写 ：

先更新 db
然后直接删除 cache

如下图：


读 :

从 cache 中读取数据，读取到就直接返回
cache 中读取不到的话，就从 db 中读取数据返回
再把数据放到 cache 中

步骤如下图


思考这一个问题：如果在写数据的过程中，可以先删除cache，再更新DB吗？ 
答案： 答案肯定是不行的，因为这样子可能造成数据库和缓存数据不一致的问题，比如这个时候有一个数据在DB和缓存都为100，请求1需要将这个数据更新写成200，如果先删除换出再 ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/post/9a0369ec.html" title="布隆过滤器"><img class="post-bg" src="/img/wallhaven-6ojj2w.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="布隆过滤器"></a></div><div class="recent-post-info"><a class="article-title" href="/post/9a0369ec.html" title="布隆过滤器">布隆过滤器</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2023-02-25T12:01:05.000Z" title="发表于 2023-02-25 20:01:05">2023-02-25</time></span></div><div class="content">文章内容来自https://juejin.cn/post/6875872519103102989
什么是 BloomFilter布隆过滤器（英语：Bloom Filter）是 1970 年由布隆提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。主要用于判断一个元素是否在一个集合中。
通常我们会遇到很多要判断一个元素是否在某个集合中的业务场景，一般想到的是将集合中所有元素保存起来，然后通过比较确定。链表、树、散列表（又叫哈希表，Hash table）等等数据结构都是这种思路。但是随着集合中元素的增加，我们需要的存储空间也会呈现线性增长，最终达到瓶颈。同时检索速度也越来越慢，上述三种结构的检索时间复杂度分别为O(n)，O(logn)，O(1)。
这个时候，布隆过滤器（Bloom Filter）就应运而生。
布隆过滤器原理了解布隆过滤器原理之前，先回顾下 Hash 函数原理。
哈希函数哈希函数的概念是：将任意大小的输入数据转换成特定大小的输出数据的函数，转换后的数据称为哈希值或哈希编码，也叫散列值。下面是一幅示意图：


所有散列函数都有如下基本特性：

如果两个散列值是不相同的（ ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/post/8fc8c009.html" title="HashMap的遍历方式与性能分析"><img class="post-bg" src="/img/wallhaven-6q6e9l.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="HashMap的遍历方式与性能分析"></a></div><div class="recent-post-info"><a class="article-title" href="/post/8fc8c009.html" title="HashMap的遍历方式与性能分析">HashMap的遍历方式与性能分析</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2023-02-24T03:01:42.000Z" title="发表于 2023-02-24 11:01:42">2023-02-24</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a></span></div><div class="content">文章内容来自https://mp.weixin.qq.com/s/zQBN3UvJDhRTKP6SzcZFKw
HashMap 遍历HashMap 遍历从大的方向来说，可分为以下 4 类：

迭代器（Iterator）方式遍历；
For Each 方式遍历；
Lambda 表达式遍历（JDK 1.8+）;
Streams API 遍历（JDK 1.8+）。

但每种类型下又有不同的实现方式，因此具体的遍历方式又可以分为以下 7 种：

使用迭代器（Iterator）EntrySet 的方式进行遍历；
使用迭代器（Iterator）KeySet 的方式进行遍历；
使用 For Each EntrySet 的方式进行遍历；
使用 For Each KeySet 的方式进行遍历；
使用 Lambda 表达式的方式进行遍历；
使用 Streams API 单线程的方式进行遍历；
使用 Streams API 多线程的方式进行遍历。

接下来我们来看每种遍历方式的具体实现代码。
1.迭代器 EntrySet1234567891011121314151617public class HashMap ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/post/8d17cdf0.html" title="jwt"><img class="post-bg" src="/img/wallhaven-mddzq8.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="jwt"></a></div><div class="recent-post-info"><a class="article-title" href="/post/8d17cdf0.html" title="jwt">jwt</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2023-02-21T04:43:20.000Z" title="发表于 2023-02-21 12:43:20">2023-02-21</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a></span></div><div class="content">JWT 实战教程

1.什么是JWTJSON Web Token (JWT) is an open standard (RFC 7519) that defines a compact and self-contained way for securely transmitting information between parties as a JSON object. This information can be verified and trusted because it is digitally signed. JWTs can be signed using a secret (with the HMAC algorithm) or a public&#x2F;private key pair using RSA or ECDSA.
​																																																											—[摘自官网]
123456# 1.翻译-  官网地址: https://jwt.io/introduction/-  翻 ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/post/23167f1b.html" title="ArrayList扩容机制"><img class="post-bg" src="/img/wallhaven-rdzx7w.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ArrayList扩容机制"></a></div><div class="recent-post-info"><a class="article-title" href="/post/23167f1b.html" title="ArrayList扩容机制">ArrayList扩容机制</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2023-02-20T02:51:47.000Z" title="发表于 2023-02-20 10:51:47">2023-02-20</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a></span></div><div class="content">文章内容来自https://juejin.cn/post/6844903582194466824
ArrayList的构造方法在说构造方法之前我们要先看下与构造参数有关的几个全局变量：
1234567891011121314151617181920212223/** * ArrayList 默认的数组容量 */ private static final int DEFAULT_CAPACITY = 10;/** * 这是一个共享的空的数组实例，当使用 ArrayList(0) 或者 ArrayList(Collection&lt;? extends E&gt; c)  * 并且 c.size() = 0 的时候讲 elementData 数组讲指向这个实例对象。 */ private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;/** * 另一个共享空数组实例，再第一次 add 元素的时候将使用它来判断数组大小是否设置为 DEFAULT_CAPACITY */ private static final Object[]  ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/post/e29c8e30.html" title="java反射"><img class="post-bg" src="/img/wallhaven-zm8doo.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="java反射"></a></div><div class="recent-post-info"><a class="article-title" href="/post/e29c8e30.html" title="java反射">java反射</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2023-02-19T06:51:30.000Z" title="发表于 2023-02-19 14:51:30">2023-02-19</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a></span></div><div class="content">文章转载于https://juejin.cn/post/6844904005294882830
一、Java 反射机制
Java 反射机制在程序运行时，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性。这种 动态的获取信息 以及 动态调用对象的方法 的功能称为 java 的反射机制。


反射机制很重要的一点就是“运行时”，其使得我们可以在程序运行时加载、探索以及使用编译期间完全未知的 .class 文件。换句话说，Java 程序可以加载一个运行时才得知名称的 .class 文件，然后获悉其完整构造，并生成其对象实体、或对其 fields（变量）设值、或调用其 methods（方法）。

二、使用反射获取类的信息为使得测试结果更加明显，首先定义了一个 FatherClass 类（默认继承自 Object 类），然后定义一个继承自 FatherClass 类的 SonClass 类，如下所示。可以看到测试类中变量以及方法的访问权限不是很规范，是为了更明显得查看测试结果而故意设置的，实际项目中不提倡这么写。
FatherClass.jav ...</div></div></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span><a class="page-number" href="/page/2/#content-inner">2</a><a class="extend next" rel="next" href="/page/2/#content-inner"><i class="fas fa-chevron-right fa-fw"></i></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/3534643.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">LIM</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Scorpios7"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Scorpios7" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到LIM的知识海洋</div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/32178238.html" title="认识JVM"><img src="/img/wallhaven-vg69p3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="认识JVM"/></a><div class="content"><a class="title" href="/post/32178238.html" title="认识JVM">认识JVM</a><time datetime="2023-02-28T01:54:40.000Z" title="发表于 2023-02-28 09:54:40">2023-02-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/4e62fa9c.html" title="Redis可持久化机制"><img src="/img/wallhaven-zxyy5w.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis可持久化机制"/></a><div class="content"><a class="title" href="/post/4e62fa9c.html" title="Redis可持久化机制">Redis可持久化机制</a><time datetime="2023-02-26T12:57:19.000Z" title="发表于 2023-02-26 20:57:19">2023-02-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/d2f8097a.html" title="Redis数据类型详解"><img src="/img/wallhaven-x8kkd3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis数据类型详解"/></a><div class="content"><a class="title" href="/post/d2f8097a.html" title="Redis数据类型详解">Redis数据类型详解</a><time datetime="2023-02-26T12:32:06.000Z" title="发表于 2023-02-26 20:32:06">2023-02-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/fd42e092.html" title="什么是消息队列"><img src="/img/wallhaven-yxm6z7.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="什么是消息队列"/></a><div class="content"><a class="title" href="/post/fd42e092.html" title="什么是消息队列">什么是消息队列</a><time datetime="2023-02-26T07:28:28.000Z" title="发表于 2023-02-26 15:28:28">2023-02-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/1f34c3f3.html" title="Redis三种常用的缓存读写策略"><img src="/img/wallhaven-r2o1w1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis三种常用的缓存读写策略"/></a><div class="content"><a class="title" href="/post/1f34c3f3.html" title="Redis三种常用的缓存读写策略">Redis三种常用的缓存读写策略</a><time datetime="2023-02-25T12:57:05.000Z" title="发表于 2023-02-25 20:57:05">2023-02-25</time></div></div></div></div><div class="card-widget card-categories"><div class="item-headline">
            <i class="fas fa-folder-open"></i>
            <span>分类</span>
            
            </div>
            <ul class="card-category-list" id="aside-cat-list">
            <li class="card-category-list-item "><a class="card-category-list-link" href="/categories/leetcode/"><span class="card-category-list-name">leetcode</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/vue/"><span class="card-category-list-name">vue</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/"><span class="card-category-list-name">剑指offer</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E5%90%8E%E7%AB%AF/"><span class="card-category-list-name">后端</span><span class="card-category-list-count">8</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E6%97%A5%E8%AF%AD%E5%AD%A6%E4%B9%A0/"><span class="card-category-list-name">日语学习</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"><span class="card-category-list-name">算法竞赛</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E7%BD%91%E7%AB%99%E8%B5%84%E6%BA%90/"><span class="card-category-list-name">网站资源</span><span class="card-category-list-count">1</span></a></li>
            </ul></div><div class="card-widget card-tags"><div class="item-headline"><i class="fas fa-tags"></i><span>标签</span></div><div class="card-tag-cloud"><a href="/tags/acm/" style="font-size: 1.23em; color: #999ea6">acm</a> <a href="/tags/docker/" style="font-size: 1.1em; color: #999">docker</a> <a href="/tags/element-ui/" style="font-size: 1.1em; color: #999">element-ui</a> <a href="/tags/java%E5%8F%8D%E5%B0%84/" style="font-size: 1.1em; color: #999">java反射</a> <a href="/tags/java%E9%9B%86%E5%90%88/" style="font-size: 1.23em; color: #999ea6">java集合</a> <a href="/tags/jvm/" style="font-size: 1.1em; color: #999">jvm</a> <a href="/tags/jwt/" style="font-size: 1.1em; color: #999">jwt</a> <a href="/tags/leetcode/" style="font-size: 1.23em; color: #999ea6">leetcode</a> <a href="/tags/redis/" style="font-size: 1.37em; color: #99a4b2">redis</a> <a href="/tags/vue/" style="font-size: 1.1em; color: #999">vue</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 1.1em; color: #999">前端</a> <a href="/tags/%E5%89%91%E6%8C%87offer/" style="font-size: 1.1em; color: #999">剑指offer</a> <a href="/tags/%E5%A4%96%E8%AF%AD%E5%AD%A6%E4%B9%A0/" style="font-size: 1.1em; color: #999">外语学习</a> <a href="/tags/%E6%97%A5%E8%AF%AD%E5%AD%A6%E4%B9%A0/" style="font-size: 1.1em; color: #999">日语学习</a> <a href="/tags/%E6%A8%A1%E6%9D%BF/" style="font-size: 1.1em; color: #999">模板</a> <a href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" style="font-size: 1.1em; color: #999">消息队列</a> <a href="/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/" style="font-size: 1.23em; color: #999ea6">算法竞赛</a> <a href="/tags/%E7%BD%91%E7%AB%99%E8%B5%84%E6%BA%90/" style="font-size: 1.1em; color: #999">网站资源</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 1.5em; color: #99a9bf">面试</a></div></div><div class="card-widget card-archives"><div class="item-headline"><i class="fas fa-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/02/"><span class="card-archive-list-date">二月 2023</span><span class="card-archive-list-count">17</span></a></li></ul></div><div class="card-widget card-webinfo"><div class="item-headline"><i class="fas fa-chart-line"></i><span>网站资讯</span></div><div class="webinfo"><div class="webinfo-item"><div class="item-name">文章数目 :</div><div class="item-count">17</div></div><div class="webinfo-item"><div class="item-name">已运行时间 :</div><div class="item-count" id="runtimeshow" data-publishDate="2023-02-16T11:00:00.000Z"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">本站总字数 :</div><div class="item-count">101.5k</div></div><div class="webinfo-item"><div class="item-name">最后更新时间 :</div><div class="item-count" id="last-push-date" data-lastPushDate="2023-02-28T02:24:38.813Z"><i class="fa-solid fa-spinner fa-spin"></i></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 By LIM</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>window.typedJSFn = {
  init: (str) => {
    window.typed = new Typed('#subtitle', Object.assign({
      strings: str,
      startDelay: 300,
      typeSpeed: 150,
      loop: true,
      backSpeed: 50,
    }, null))
  },
  run: (subtitleType) => {
    if (true) {
      if (typeof Typed === 'function') {
        subtitleType()
      } else {
        getScript('https://cdn.jsdelivr.net/npm/typed.js/lib/typed.min.js').then(subtitleType)
      }
    } else {
      subtitleType()
    }
  }
}
</script><script>function subtitleType () {
  if (true) {
    typedJSFn.init(["曾迷途才怕追不上滿街趕路人 無人理睬如何求生","頑童大了沒那麼笨 可以聚腳於康莊旅途","然後同沐浴溫泉 為何在雨傘外獨行"])
  } else {
    document.getElementById("subtitle").innerHTML = '曾迷途才怕追不上滿街趕路人 無人理睬如何求生'
  }
}
typedJSFn.run(subtitleType)</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>