<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>leetcode题集 | LIMの博客</title><meta name="author" content="LIM"><meta name="copyright" content="LIM"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="错题树图图中的最长环link:[2360. 图中的最长环 - 力扣（LeetCode）](https:&#x2F;&#x2F;leetcode.cn&#x2F;problems&#x2F;longest-cycle-in-a-graph&#x2F;)   tips:一个点最多只有一个出边 12# 题解：并查集找连通快- 看该点和他连接的点是否在一个连通块中，如果在，则加上这条边可组成一个环  code1 123456789101112131415">
<meta property="og:type" content="article">
<meta property="og:title" content="leetcode题集">
<meta property="og:url" content="http://example.com/post/dd65d9fe.html">
<meta property="og:site_name" content="LIMの博客">
<meta property="og:description" content="错题树图图中的最长环link:[2360. 图中的最长环 - 力扣（LeetCode）](https:&#x2F;&#x2F;leetcode.cn&#x2F;problems&#x2F;longest-cycle-in-a-graph&#x2F;)   tips:一个点最多只有一个出边 12# 题解：并查集找连通快- 看该点和他连接的点是否在一个连通块中，如果在，则加上这条边可组成一个环  code1 123456789101112131415">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/wallhaven-l35pw2.jpg">
<meta property="article:published_time" content="2023-02-17T11:31:22.000Z">
<meta property="article:modified_time" content="2023-02-28T02:41:33.768Z">
<meta property="article:author" content="LIM">
<meta property="article:tag" content="leetcode">
<meta property="article:tag" content="acm">
<meta property="article:tag" content="算法竞赛">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/wallhaven-l35pw2.jpg"><link rel="shortcut icon" href="/img/letter-l.png"><link rel="canonical" href="http://example.com/post/dd65d9fe.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'leetcode题集',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-02-28 10:41:33'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/background.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/3534643.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 时间轴</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="LIMの博客"><span class="site-name">LIMの博客</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 时间轴</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">leetcode题集</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-02-17T11:31:22.000Z" title="发表于 2023-02-17 19:31:22">2023-02-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-02-28T02:41:33.768Z" title="更新于 2023-02-28 10:41:33">2023-02-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/leetcode/">leetcode</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">17.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>94分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="leetcode题集"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="错题"><a href="#错题" class="headerlink" title="错题"></a>错题</h1><h2 id="树图"><a href="#树图" class="headerlink" title="树图"></a>树图</h2><h3 id="图中的最长环"><a href="#图中的最长环" class="headerlink" title="图中的最长环"></a>图中的最长环</h3><p><code>link:[2360. 图中的最长环 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-cycle-in-a-graph/)</code></p>
<img src="/post/dd65d9fe/image-20220804211629253.png" alt="image-20220804211629253" style="zoom:50%;">

<p><code>tips:一个点最多只有一个出边</code></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 题解：并查集找连通快</span></span><br><span class="line"><span class="bullet">-</span> 看该点和他连接的点是否在一个连通块中，如果在，则加上这条边可组成一个环</span><br></pre></td></tr></table></figure>

<p><code>code1</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u!=p[u]) p[u]=<span class="built_in">find</span>(p[u]);</span><br><span class="line">    <span class="keyword">return</span> p[u];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> fa1=<span class="built_in">find</span>(a);</span><br><span class="line">    <span class="type">int</span> fa2=<span class="built_in">find</span>(b);</span><br><span class="line">    p[fa1]=fa2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestCycle</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=edges.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) p[i]=i;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="comment">// 如果该点有出边</span></span><br><span class="line">            <span class="keyword">if</span>(edges[i]!=<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="comment">// 若这两点处于同一个连通快中，加上这条边则构成一个环</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">find</span>(i)==<span class="built_in">find</span>(edges[i]))&#123;</span><br><span class="line">                    <span class="type">int</span> u=edges[i],ans=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">while</span>(u!=i)&#123;</span><br><span class="line">                        ans++;</span><br><span class="line">                        u=edges[u];</span><br><span class="line">                    &#125;</span><br><span class="line">                    res=<span class="built_in">max</span>(res,ans);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 将两点合并</span></span><br><span class="line">                <span class="built_in">merge</span>(i,edges[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>code2</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u!=p[u]) p[u]=<span class="built_in">find</span>(p[u]);</span><br><span class="line">    <span class="keyword">return</span> p[u];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> fa1=<span class="built_in">find</span>(a);</span><br><span class="line">    <span class="type">int</span> fa2=<span class="built_in">find</span>(b);</span><br><span class="line">    p[fa1]=fa2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestCycle</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=edges.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) p[i]=i;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(edges[i]!=<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">find</span>(i)!=<span class="built_in">find</span>(edges[i])) <span class="built_in">merge</span>(i,edges[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        set&lt;<span class="type">int</span>&gt;s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="comment">// 如果不是孤立的点，则加入集合中</span></span><br><span class="line">            <span class="keyword">if</span>(edges[i]!=<span class="number">-1</span>) s.<span class="built_in">insert</span>(<span class="built_in">find</span>(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历每一个祖父</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:s)&#123;</span><br><span class="line">            <span class="type">int</span> u=edges[x];</span><br><span class="line">            <span class="type">int</span> ans=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(u!=<span class="number">-1</span> &amp;&amp; u!=x)&#123;</span><br><span class="line">                ans++;</span><br><span class="line">                u=edges[u];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(u==x) res=<span class="built_in">max</span>(res,ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="移除最多的同行或同列石头"><a href="#移除最多的同行或同列石头" class="headerlink" title="移除最多的同行或同列石头"></a>移除最多的同行或同列石头</h3><p><code>link:https://leetcode.cn/problems/most-stones-removed-with-same-row-or-column/</code></p>
<img src="/post/dd65d9fe/image-20220811132321535.png" alt="image-20220811132321535" style="zoom:50%;">



<p><code>题解:</code></p>
<img src="/post/dd65d9fe/image-20220811132536937.png" alt="image-20220811132536937" style="zoom:50%;">



<p><code>code:</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1007</span>;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u!=p[u]) p[u]=<span class="built_in">find</span>(p[u]);</span><br><span class="line">    <span class="keyword">return</span> p[u];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="built_in">find</span>(x),y=<span class="built_in">find</span>(y);</span><br><span class="line">    p[x]=y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeStones</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">1000</span>;i++) p[i]=i;</span><br><span class="line">        <span class="type">int</span> n=a.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(a[i][<span class="number">0</span>]==a[j][<span class="number">0</span>] || a[i][<span class="number">1</span>]==a[j][<span class="number">1</span>]) <span class="built_in">merge</span>(i,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(i)==i) cnt++; <span class="comment">//不能合并的点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n-cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="修剪二叉搜索树"><a href="#修剪二叉搜索树" class="headerlink" title="修剪二叉搜索树"></a>修剪二叉搜索树</h3><p><code>link:https://leetcode.cn/problems/trim-a-binary-search-tree/</code></p>
<img src="/post/dd65d9fe/image-20220913113452179.png" alt="image-20220913113452179" style="zoom:50%;">



<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 题解</span></span><br></pre></td></tr></table></figure>

<img src="/post/dd65d9fe/image-20220913113543634.png" class title="image-20220913113543634">



<p><code>code</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">trimBST</span><span class="params">(TreeNode* root, <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> root; <span class="comment">// 如果为空，直接返回</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val&lt;low) <span class="keyword">return</span> <span class="built_in">trimBST</span>(root-&gt;right,low,high);</span><br><span class="line">        <span class="comment">// 如果该点&gt;low，那么该点和它的左子树都不行，那么就看它的右子树</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val&gt;high) <span class="keyword">return</span> <span class="built_in">trimBST</span>(root-&gt;left,low,high);</span><br><span class="line">        <span class="comment">// 如果该点&lt;high，那么该点和它的右子树都不行，那么就看它的左子树</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果该点没问题，更新答案</span></span><br><span class="line">        root-&gt;left=<span class="built_in">trimBST</span>(root-&gt;left,low,high);</span><br><span class="line">        root-&gt;right=<span class="built_in">trimBST</span>(root-&gt;right,low,high);</span><br><span class="line">        <span class="keyword">return</span> root; <span class="comment">// 该点满足，返回该点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="寻找重复的子树"><a href="#寻找重复的子树" class="headerlink" title="寻找重复的子树"></a>寻找重复的子树</h3><p><code>link:https://leetcode.cn/problems/find-duplicate-subtrees/</code></p>
<img src="/post/dd65d9fe/image-20220913120528068.png" alt="image-20220913120528068" style="zoom:50%;">



<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 题解：二叉树的序列化</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;TreeNode*&gt;res;</span><br><span class="line">    map&lt;string,<span class="type">int</span>&gt;mp;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;TreeNode*&gt; <span class="title">findDuplicateSubtrees</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">dfs</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="string">&quot;$&quot;</span>;</span><br><span class="line">        <span class="comment">// 将二叉树序列化</span></span><br><span class="line">        string s=<span class="built_in">to_string</span>(root-&gt;val)+<span class="string">&quot;val&quot;</span>+<span class="built_in">dfs</span>(root-&gt;left)+<span class="string">&quot;left&quot;</span>+<span class="built_in">dfs</span>(root-&gt;right)+<span class="string">&quot;right&quot;</span>;</span><br><span class="line">        mp[s]++;</span><br><span class="line">        <span class="keyword">if</span>(mp[s]==<span class="number">2</span>) res.<span class="built_in">push_back</span>(root);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><h3 id="优势洗牌"><a href="#优势洗牌" class="headerlink" title="优势洗牌"></a>优势洗牌</h3><p><code>link:[870. 优势洗牌 - 力扣（LeetCode）](https://leetcode.cn/problems/advantage-shuffle/)</code></p>
<img src="/post/dd65d9fe/image-20220806191355340.png" alt="image-20220806191355340" style="zoom:50%;">



<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 题解：二分，贪心</span></span><br></pre></td></tr></table></figure>

<p><code>code1(AC)</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">advantageCount</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=nums1.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;PII&gt;a;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums2.<span class="built_in">size</span>();i++) a.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(nums2[i],i));</span><br><span class="line">        <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(nums1.<span class="built_in">begin</span>(),nums1.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">res</span>(n);</span><br><span class="line">        vector&lt;<span class="type">bool</span>&gt;<span class="built_in">mp</span>(n);</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;n &amp;&amp; j&lt;n)&#123;</span><br><span class="line">            <span class="type">int</span> t=<span class="built_in">upper_bound</span>(nums1.<span class="built_in">begin</span>()+j,nums1.<span class="built_in">end</span>(),a[i].first)-nums1.<span class="built_in">begin</span>();</span><br><span class="line">            <span class="keyword">if</span>(t==n) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums1[t]&gt;a[i].first)&#123;</span><br><span class="line">                res[a[i].second]=t;</span><br><span class="line">                j=t+<span class="number">1</span>;</span><br><span class="line">                mp[t]=<span class="number">1</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;n)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==n) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span>(!mp[j])&#123;</span><br><span class="line">                    res[a[i].second]=j;</span><br><span class="line">                    mp[j]=<span class="number">1</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) ans.<span class="built_in">push_back</span>(nums1[res[i]]);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>code2</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">advantageCount</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        multiset&lt;<span class="type">int</span>&gt;s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:nums1) s.<span class="built_in">insert</span>(x);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:nums2)&#123;</span><br><span class="line">            <span class="keyword">auto</span> t=s.<span class="built_in">upper_bound</span>(x);</span><br><span class="line">            <span class="keyword">if</span>(t==s.<span class="built_in">end</span>())&#123;</span><br><span class="line">                <span class="comment">// 如果最大的都不行，那就贪心选最小的</span></span><br><span class="line">                res.<span class="built_in">push_back</span>(*s.<span class="built_in">begin</span>());</span><br><span class="line">                s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>());</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(*t);</span><br><span class="line">                s.<span class="built_in">erase</span>(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="dp"><a href="#dp" class="headerlink" title="dp"></a>dp</h2><h3 id="打家劫舍III"><a href="#打家劫舍III" class="headerlink" title="打家劫舍III"></a>打家劫舍III</h3><p><code>link:https://leetcode.cn/problems/house-robber-iii/</code></p>
<img src="/post/dd65d9fe/image-20220808132213482.png" alt="image-20220808132213482" style="zoom:50%;">



<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 题解：记忆化搜索</span></span><br></pre></td></tr></table></figure>

<p><code>code</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    map&lt;TreeNode*,<span class="type">int</span>&gt;dp;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right) <span class="keyword">return</span> root-&gt;val; <span class="comment">//如果左右孩子都为空，直接偷</span></span><br><span class="line">        <span class="keyword">if</span>(dp[root]) <span class="keyword">return</span> dp[root]; <span class="comment">//记忆化搜索</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//偷父亲</span></span><br><span class="line">        <span class="type">int</span> res1=root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left) res1+=<span class="built_in">rob</span>(root-&gt;left-&gt;left)+<span class="built_in">rob</span>(root-&gt;left-&gt;right);<span class="comment">//跳过左孩子</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right) res1+=<span class="built_in">rob</span>(root-&gt;right-&gt;left)+<span class="built_in">rob</span>(root-&gt;right-&gt;right);<span class="comment">//跳过右孩子</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//偷孩子</span></span><br><span class="line">        <span class="type">int</span> res2=<span class="built_in">rob</span>(root-&gt;left)+<span class="built_in">rob</span>(root-&gt;right);</span><br><span class="line">        dp[root]=<span class="built_in">max</span>(res1,res2);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(res1,res2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="检查数组是否存在有效划分"><a href="#检查数组是否存在有效划分" class="headerlink" title="检查数组是否存在有效划分"></a>检查数组是否存在有效划分</h3><p><code>link:https://leetcode.cn/problems/check-if-there-is-a-valid-partition-for-the-array/</code></p>
<img src="/post/dd65d9fe/image-20220809110214202.png" alt="image-20220809110214202" style="zoom:50%;">



<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># dp:dp[i]表示以第i个结尾是否存在有效划分（下标从1开始）</span></span><br><span class="line"><span class="section"># 第一种：要求连续两个数相等且i-2结尾存在有效划分</span></span><br><span class="line"><span class="section"># 第二种：要求连续三个数相等且i-3结尾存在有效划分</span></span><br><span class="line"><span class="section"># 第三种：由3个连续递增元素组成，并且相邻元素之间的差值为1，且i-3结尾存在有效划分</span></span><br><span class="line"><span class="bullet">-</span> 注意：0结尾是一种有效划分</span><br></pre></td></tr></table></figure>

<p><code>code</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">validPartition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=a.<span class="built_in">size</span>();</span><br><span class="line">        a.<span class="built_in">insert</span>(a.<span class="built_in">begin</span>(),<span class="number">0</span>);</span><br><span class="line">        vector&lt;<span class="type">bool</span>&gt;<span class="built_in">dp</span>(n+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// dp[i]表示第i位结尾是否可行</span></span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>; <span class="comment">//这里要注意，没有元素是一种有效划分</span></span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">2</span>]=(a[<span class="number">2</span>]==a[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="comment">//第一种划分</span></span><br><span class="line">            <span class="keyword">if</span>(a[i]==a[i<span class="number">-1</span>] &amp;&amp; dp[i<span class="number">-2</span>]) dp[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 第二种划分</span></span><br><span class="line">            <span class="keyword">if</span>(a[i]==a[i<span class="number">-1</span>] &amp;&amp; a[i<span class="number">-1</span>]==a[i<span class="number">-2</span>] &amp;&amp; dp[i<span class="number">-3</span>]) dp[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//第三种划分</span></span><br><span class="line">            <span class="keyword">if</span>(a[i]==a[i<span class="number">-1</span>]+<span class="number">1</span> &amp;&amp; a[i<span class="number">-1</span>]==a[i<span class="number">-2</span>]+<span class="number">1</span> &amp;&amp; dp[i<span class="number">-3</span>]) dp[i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="到家的最少跳跃次数"><a href="#到家的最少跳跃次数" class="headerlink" title="到家的最少跳跃次数"></a>到家的最少跳跃次数</h3><p><code>link:https://leetcode.cn/problems/minimum-jumps-to-reach-home/</code></p>
<img src="/post/dd65d9fe/image-20220809223657760.png" alt="image-20220809223657760" style="zoom:50%;">



<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 题解：bfs+dp</span></span><br><span class="line"><span class="section"># 看到这种向左向右跳的模型首先想到bdf求最短路，因为不能连续向后跳两次，所以可以用dp记录状态并求最短距离</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> j-&gt;i</span><br><span class="line"><span class="bullet">-</span> dp[<span class="string">i</span>][<span class="symbol">0</span>]表示向前跳到i的最小步数  tip:可以由dp[<span class="string">j</span>][<span class="symbol">0</span>]和dp[<span class="string">j</span>][<span class="symbol">1</span>]转移</span><br><span class="line"><span class="bullet">-</span> dp[<span class="string">i</span>][<span class="symbol">1</span>]表示向后跳到i的最小步数  tip:该方程必须由dp[<span class="string">j</span>][<span class="symbol">0</span>]转移，因为不能连续往后跳两次</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> vector<span class="language-xml"><span class="tag">&lt;<span class="name">bool</span>&gt;</span></span>front(6007); // 记录向前跳是否到过该点</span><br><span class="line"><span class="bullet">-</span> vector<span class="language-xml"><span class="tag">&lt;<span class="name">bool</span>&gt;</span></span>back(6007); //记录向后跳是否到过该点</span><br><span class="line"><span class="bullet">-</span> 开到6007的原因，6007可以覆盖4001-6000的所有点</span><br><span class="line"><span class="bullet">-</span> front和back是相互独立的，之前向前到过该点就不能继续往前跳到这个点(bfs求最短路原理)，向后同理</span><br></pre></td></tr></table></figure>

<p><code>code(AC)</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumJumps</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; forbidden, <span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">dp</span>(<span class="number">6007</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>,<span class="number">1e9</span>));</span><br><span class="line">        <span class="comment">// dp[i][0]表示到达这个位置是向前跳到i的最小步数，</span></span><br><span class="line">        <span class="comment">// dp[i][1]表示到达这个位置是向后跳到i的最小步数</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=dp[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">bool</span>&gt;<span class="built_in">front</span>(<span class="number">6007</span>); <span class="comment">// 记录向前跳是否到过该点</span></span><br><span class="line">        vector&lt;<span class="type">bool</span>&gt;<span class="built_in">back</span>(<span class="number">6007</span>); <span class="comment">//记录向后跳是否到过该点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:forbidden) front[x]=back[x]=<span class="number">1</span>;</span><br><span class="line">        front[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        back[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">        q.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="type">int</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">// -&gt;front</span></span><br><span class="line">            <span class="type">int</span> ed=t+a;</span><br><span class="line">            <span class="keyword">if</span>(ed&lt;=<span class="number">6000</span> &amp;&amp; !front[ed])&#123;</span><br><span class="line">                dp[ed][<span class="number">0</span>]=<span class="built_in">min</span>(dp[t][<span class="number">0</span>],dp[t][<span class="number">1</span>])+<span class="number">1</span>;</span><br><span class="line">                front[ed]=<span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(ed);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// -&gt;back</span></span><br><span class="line">            ed=t-b;</span><br><span class="line">            <span class="keyword">if</span>(ed&gt;<span class="number">0</span> &amp;&amp; !back[ed])&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[t][<span class="number">0</span>]&gt;=<span class="number">1e9</span>) <span class="keyword">continue</span>;</span><br><span class="line">                dp[ed][<span class="number">1</span>]=dp[t][<span class="number">0</span>]+<span class="number">1</span>;</span><br><span class="line">                back[ed]=<span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(ed);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res=<span class="built_in">min</span>(dp[x][<span class="number">0</span>],dp[x][<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span>(res==<span class="number">1e9</span>) res=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="解决智力问题"><a href="#解决智力问题" class="headerlink" title="解决智力问题"></a>解决智力问题</h3><p><code>link:https://leetcode.cn/problems/solving-questions-with-brainpower/</code></p>
<img src="/post/dd65d9fe/image-20220820145543735.png" alt="image-20220820145543735" style="zoom:50%;">



<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 反向dp：考虑到当前点，有两种情况，选和不选</span></span><br><span class="line"><span class="section"># 选：因为选了后后面brainpower个点都不能选，所以直接从第i+barinpower点转移过来</span></span><br><span class="line"><span class="section"># 不选：从i+1转移过来</span></span><br></pre></td></tr></table></figure>

<p><code>code</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">mostPoints</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; questions)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=questions.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;LL&gt;&gt;<span class="built_in">dp</span>(n+<span class="number">7</span>,<span class="built_in">vector</span>&lt;LL&gt;(<span class="number">2</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=<span class="built_in">max</span>(dp[i+<span class="number">1</span>][<span class="number">0</span>],dp[i+<span class="number">1</span>][<span class="number">1</span>]); <span class="comment">// 不选</span></span><br><span class="line">            <span class="type">int</span> right=<span class="built_in">min</span>(i+questions[i][<span class="number">1</span>]+<span class="number">1</span>,n);</span><br><span class="line">            dp[i][<span class="number">1</span>]=questions[i][<span class="number">0</span>]+<span class="built_in">max</span>(dp[right][<span class="number">0</span>],dp[right][<span class="number">1</span>]);<span class="comment">// 选</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[<span class="number">0</span>][<span class="number">0</span>],dp[<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">mostPoints</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; questions)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=questions.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;LL&gt;<span class="built_in">dp</span>(n+<span class="number">7</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="type">int</span> right=<span class="built_in">min</span>(i+questions[i][<span class="number">1</span>]+<span class="number">1</span>,n);</span><br><span class="line">            dp[i]=<span class="built_in">max</span>(dp[i+<span class="number">1</span>],dp[right]+questions[i][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="不同的二叉搜索树"><a href="#不同的二叉搜索树" class="headerlink" title="不同的二叉搜索树"></a>不同的二叉搜索树</h3><p><code>link:https://leetcode.cn/problems/unique-binary-search-trees/</code></p>
<img src="/post/dd65d9fe/image-20220901102701565.png" alt="image-20220901102701565" style="zoom:50%;">



<p><code>题解</code></p>
<img src="/post/dd65d9fe/image-20220901102742041.png" alt="image-20220901102742041" style="zoom:50%;">



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numTrees</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">dp</span>(n+<span class="number">1</span>);</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123; <span class="comment">// dp[i]表示i个节点组成的二叉搜索树有多少种</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)&#123; <span class="comment">// 枚举根节点</span></span><br><span class="line">                dp[i]+=dp[j<span class="number">-1</span>]*dp[i-j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="对字符串可执行的最大删除数"><a href="#对字符串可执行的最大删除数" class="headerlink" title="对字符串可执行的最大删除数"></a>对字符串可执行的最大删除数</h3><p>​	<code>link:https://leetcode.cn/problems/maximum-deletions-on-a-string/</code></p>
<img src="/post/dd65d9fe/image-20221004112337275.png" alt="image-20221004112337275" style="zoom:50%;">

<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 题解：哈希+dp</span></span><br><span class="line"><span class="section"># 设dp[i]表示[i,n]能删除的最大次数,考虑第i个点,枚举长度,看后面是否存在跟[i,j]相等的子串,若存在[i,j]的子串跟[j+1,len]相等，则更新答案,即dp[i]=max(dp[i],dp[j+1]+1)，最后答案为dp[1]+1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ULL;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ULL h[<span class="number">4010</span>],p[<span class="number">4010</span>];</span><br><span class="line">    <span class="type">int</span> dp[<span class="number">4010</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function">ULL <span class="title">get</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> h[r]-h[l<span class="number">-1</span>]*p[r-l+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">deleteString</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=s.<span class="built_in">length</span>();</span><br><span class="line">        s=<span class="string">&quot;#&quot;</span>+s;</span><br><span class="line">        p[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            p[i]=p[i<span class="number">-1</span>]*<span class="number">131</span>;</span><br><span class="line">            h[i]=h[i<span class="number">-1</span>]*<span class="number">131</span>+s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="type">int</span> len=j-i+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(j+len&gt;n) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">get</span>(i,j)==<span class="built_in">get</span>(j+<span class="number">1</span>,j+len)) dp[i]=<span class="built_in">max</span>(dp[i],dp[j+<span class="number">1</span>]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="树上最大得分和路径"><a href="#树上最大得分和路径" class="headerlink" title="树上最大得分和路径"></a>树上最大得分和路径</h3><p><code>link:https://leetcode.cn/problems/most-profitable-path-in-a-tree/description/</code></p>
<img src="/post/dd65d9fe/image-20221113175847998.png" alt="image-20221113175847998" style="zoom:50%;">



<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 题解</span></span><br><span class="line"><span class="section"># 1.因为每个节点只有一个父亲,所以Bob的路径是唯一的</span></span><br><span class="line"><span class="section"># 2.先进行一次dfs,算出每个节点的深度</span></span><br><span class="line"><span class="section"># 3.再dfs算出bob到达每个节点的时间</span></span><br><span class="line"><span class="section"># 4.最后进行dp,根据Alice到达的时间跟Bob进行比较</span></span><br><span class="line"><span class="section"># - 若time&gt;t[u],则u节点的贡献为0</span></span><br><span class="line"><span class="section"># - 若Bob没有经过u或者time<span class="language-xml">&lt;t[u],则u节点的贡献为amount[u]</span></span></span><br><span class="line"><span class="language-xml"><span class="section"># - 若time==t[u],则u节点的贡献为amount[u]/2</span></span></span><br></pre></td></tr></table></figure>

<p><code>code</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100007</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> depth[N];</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;g[N];</span><br><span class="line">    <span class="type">int</span> dp[N];</span><br><span class="line">    <span class="type">int</span> t[N];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">mostProfitablePath</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges, <span class="type">int</span> bob, vector&lt;<span class="type">int</span>&gt;&amp; amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:edges)&#123;</span><br><span class="line">            g[x[<span class="number">0</span>]].<span class="built_in">push_back</span>(x[<span class="number">1</span>]);</span><br><span class="line">            g[x[<span class="number">1</span>]].<span class="built_in">push_back</span>(x[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(t,<span class="number">-1</span>,<span class="keyword">sizeof</span> t);</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">dfs1</span>(bob,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">dfs2</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,amount);</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> dep,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">        depth[u]=dep;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;son:g[u])&#123;</span><br><span class="line">            <span class="keyword">if</span>(fa==son) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(son,dep+<span class="number">1</span>,u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> time)</span></span>&#123;</span><br><span class="line">        t[u]=time;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;son:g[u])&#123;</span><br><span class="line">            <span class="keyword">if</span>(depth[son]&lt;depth[u]) <span class="built_in">dfs1</span>(son,time+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> time,<span class="type">int</span> fa,vector&lt;<span class="type">int</span>&gt;&amp; amount)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(t[u]==<span class="number">-1</span> || time&lt;t[u]) ans=amount[u];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(time==t[u]) ans=amount[u]/<span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> maxson=<span class="number">-2e9</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;son:g[u])&#123;</span><br><span class="line">            <span class="keyword">if</span>(son==fa) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">dfs2</span>(son,time+<span class="number">1</span>,u,amount);</span><br><span class="line">            maxson=<span class="built_in">max</span>(maxson,dp[son]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(maxson==<span class="number">-2e9</span>) maxson=<span class="number">0</span>;</span><br><span class="line">        dp[u]=ans+maxson;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="删除链表中的节点"><a href="#删除链表中的节点" class="headerlink" title="删除链表中的节点"></a>删除链表中的节点</h3><p><code>link:https://leetcode.cn/problems/delete-node-in-a-linked-list/</code></p>
<img src="/post/dd65d9fe/image-20220810105651356.png" alt="image-20220810105651356" style="zoom:50%;">



<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 题解：如何让自己在世界上消失，但又不死？</span></span><br><span class="line"><span class="section"># ————将自己完全变成另一个人，再杀了那个人就行了</span></span><br></pre></td></tr></table></figure>

<p><code>code</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteNode</span><span class="params">(ListNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 既然不能干掉自己，那就把自己变成别人，再干掉别人</span></span><br><span class="line">        node-&gt;val=node-&gt;next-&gt;val;</span><br><span class="line">        node-&gt;next=node-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 另一种写法</span></span><br><span class="line">        <span class="comment">//*(node)=*(node-&gt;next);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="环形子数组的最大和"><a href="#环形子数组的最大和" class="headerlink" title="环形子数组的最大和"></a>环形子数组的最大和</h3><p><code>link:https://leetcode.cn/problems/maximum-sum-circular-subarray/</code></p>
<img src="/post/dd65d9fe/image-20220810134816979.png" alt="image-20220810134816979" style="zoom:50%;">



<p><code>题解</code></p>
<img src="/post/dd65d9fe/image-20220810134904313.png" class title="image-20220810134904313">



<p><code>code</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubarraySumCircular</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">-1e9</span>;</span><br><span class="line">        <span class="type">int</span> n=a.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">sum</span>(n*<span class="number">2</span>+<span class="number">7</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            a.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">            res=<span class="built_in">max</span>(res,a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        a.<span class="built_in">insert</span>(a.<span class="built_in">begin</span>(),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++) sum[i]=sum[i<span class="number">-1</span>]+a[i];</span><br><span class="line">        deque&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++)&#123;</span><br><span class="line">            <span class="comment">// 为什么是大于n? 因为答案是sum[i]-sum[q.front()],不包括q.front这个点</span></span><br><span class="line">            <span class="keyword">if</span>(q.<span class="built_in">size</span>() &amp;&amp; i-q.<span class="built_in">front</span>()&gt;n) q.<span class="built_in">pop_front</span>();</span><br><span class="line">            <span class="comment">// 保证队列单调递增</span></span><br><span class="line">            <span class="keyword">while</span>(q.<span class="built_in">size</span>() &amp;&amp; sum[q.<span class="built_in">back</span>()]&gt;=sum[i]) q.<span class="built_in">pop_back</span>();</span><br><span class="line">            <span class="keyword">if</span>(q.<span class="built_in">size</span>()) res=<span class="built_in">max</span>(res,sum[i]-sum[q.<span class="built_in">front</span>()]);</span><br><span class="line">            q.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="字符串的前缀分数和"><a href="#字符串的前缀分数和" class="headerlink" title="字符串的前缀分数和"></a>字符串的前缀分数和</h3><p><code>link:https://leetcode.cn/problems/sum-of-prefix-scores-of-strings/</code></p>
<img src="/post/dd65d9fe/image-20221002230813988.png" alt="image-20221002230813988" style="zoom:50%;">

<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 字典树模板题</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> trie[<span class="number">1000001</span>][<span class="number">26</span>];</span><br><span class="line"><span class="type">int</span> cnt[<span class="number">1000100</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> root=<span class="number">0</span>; <span class="comment">// 所有节点的祖先</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:s)&#123;</span><br><span class="line">            <span class="type">int</span> u=x-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(!trie[root][u]) trie[root][u]=++idx;</span><br><span class="line">            root=trie[root][u]; <span class="comment">// 跳到下一个点</span></span><br><span class="line">            cnt[root]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">query</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> root=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:s)&#123;</span><br><span class="line">            <span class="type">int</span> u=x-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            root=trie[root][u];</span><br><span class="line">            ans+=cnt[root];</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">push_back</span>(ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> idx;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;res;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sumPrefixScores</span><span class="params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(trie,<span class="number">0</span>,<span class="keyword">sizeof</span> trie);</span><br><span class="line">        <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="keyword">sizeof</span> cnt);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:words) <span class="built_in">insert</span>(x);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:words) <span class="built_in">query</span>(x);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="括号的分数"><a href="#括号的分数" class="headerlink" title="括号的分数"></a>括号的分数</h3><p><code>link:https://leetcode.cn/problems/score-of-parentheses/</code></p>
<img src="/post/dd65d9fe/image-20221009110035188.png" alt="image-20221009110035188" style="zoom:50%;">



<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 题解:</span></span><br><span class="line"><span class="section"># 先把子括号串算出来,然后更新大的,这个过程可以用栈实现</span></span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">scoreOfParentheses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt;st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:s)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x==<span class="string">&#x27;(&#x27;</span>) st.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">int</span> val=st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(!st.<span class="built_in">size</span>()) st.<span class="built_in">push</span>(<span class="built_in">max</span>(<span class="number">2</span>*val,<span class="number">1</span>));</span><br><span class="line">                <span class="keyword">else</span> st.<span class="built_in">top</span>()+=<span class="built_in">max</span>(<span class="number">2</span>*val,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> st.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h2 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h2><h3 id="袋子里最少数目的球"><a href="#袋子里最少数目的球" class="headerlink" title="袋子里最少数目的球"></a>袋子里最少数目的球</h3><p><code>link:https://leetcode.cn/problems/minimum-limit-of-balls-in-a-bag/</code></p>
<img src="/post/dd65d9fe/image-20220821170309850.png" alt="image-20220821170309850" style="zoom:50%;">



<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 二分答案，在check中判断操作的次数是否小于maxOperations</span></span><br></pre></td></tr></table></figure>

<p><code>code</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumSize</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> maxOperations)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">1</span>,r=<span class="number">1e9</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(mid,nums,maxOperations)) r=mid;</span><br><span class="line">            <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> mid,vector&lt;<span class="type">int</span>&gt;&amp; a,<span class="type">int</span> cnt)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:a)&#123;</span><br><span class="line">            res+=x/mid;</span><br><span class="line">            <span class="keyword">if</span>(x%mid==<span class="number">0</span>) res--; <span class="comment">//如果能除尽res要-1，例如9-&gt;3只需要两次</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res&lt;=cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="按位或最大的最小子数组长度"><a href="#按位或最大的最小子数组长度" class="headerlink" title="按位或最大的最小子数组长度"></a>按位或最大的最小子数组长度</h3><img src="/post/dd65d9fe/image-20220930221854569.png" alt="image-20220930221854569" style="zoom:50%;">

<p><code>link:https://leetcode.cn/problems/smallest-subarrays-with-maximum-bitwise-or/</code></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 题解:贪心+二分</span></span><br><span class="line"><span class="section"># 首先将二进制31位对应的所有下标存起来</span></span><br><span class="line"><span class="section"># 然后遍历数组每一个数的31位，如果这个数的二进制有第j位，则这一位不需要其他数来取或值，若没有，则需要从后面的数二进制有该位的数中二分取大于这个数的最小值，最终答案取最大，具体看代码</span></span><br></pre></td></tr></table></figure>

<p><code>code</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">smallestSubarrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=a.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;bits[<span class="number">32</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">31</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(a[i]&gt;&gt;j&amp;<span class="number">1</span>) bits[j].<span class="built_in">push_back</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;res;</span><br><span class="line">        <span class="type">int</span> p;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            p=i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">31</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(a[i]&gt;&gt;j&amp;<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(!bits[j].<span class="built_in">size</span>()) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">auto</span> t=<span class="built_in">upper_bound</span>(bits[j].<span class="built_in">begin</span>(),bits[j].<span class="built_in">end</span>(),i);</span><br><span class="line">                <span class="keyword">if</span>(t!=bits[j].<span class="built_in">end</span>()) p=<span class="built_in">max</span>(p,*t);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(p-i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><h3 id="从字符串中移除星号"><a href="#从字符串中移除星号" class="headerlink" title="从字符串中移除星号"></a>从字符串中移除星号</h3><p><code>link:https://leetcode.cn/problems/removing-stars-from-a-string/</code></p>
<img src="/post/dd65d9fe/image-20220831143610762.png" alt="image-20220831143610762" style="zoom:50%;">



<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># string的用法</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeStars</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:s)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x!=<span class="string">&#x27;*&#x27;</span>) res.<span class="built_in">push_back</span>(x);</span><br><span class="line">            <span class="keyword">else</span> res.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="int和string的相互转换"><a href="#int和string的相互转换" class="headerlink" title="int和string的相互转换"></a>int和string的相互转换</h3><blockquote>
<p>int转string: to_string(i)</p>
<p>string转int: atoi(s.c_str())</p>
</blockquote>
<h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><p><code>vector.front():vector的第一个元素</code></p>
<p><code>vector.back():vector的最后一个元素</code></p>
<p><code>vector.pop_back():vector删除最后一个元素</code></p>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>1.最小值: s.begin()</p>
<p>2.最大值: s.rbegin()</p>
<p>3.删除最后一个元素: s.erase(–s.end());</p>
<h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p>1.find:</p>
<p>s.find(“abc”): 返回abc出现第一次的a的下标，不存在返回-1</p>
<p>s.find(“abc”,3): 从下标3开始找</p>
<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><h3 id="统计定界子数组的数目"><a href="#统计定界子数组的数目" class="headerlink" title="统计定界子数组的数目"></a>统计定界子数组的数目</h3><p><code>link:https://leetcode.cn/problems/count-subarrays-with-fixed-bounds/</code></p>
<img src="/post/dd65d9fe/image-20221017184839341.png" alt="image-20221017184839341" style="zoom:50%;">



<p><code>题解</code></p>
<img src="/post/dd65d9fe/typora_image\image-20221017184906358.png" alt="image-20221017184906358" style="zoom:50%;">

<p><code>code</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">countSubarrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> minK, <span class="type">int</span> maxK)</span> </span>&#123;</span><br><span class="line">        LL res=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r1=<span class="number">-1</span>,r2=<span class="number">-1</span>,l=<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 以i为右边界统计答案</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&lt;minK || nums[i]&gt;maxK) l=i; <span class="comment">// 最左边不满足条件的下标</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i]==minK) r1=i; <span class="comment">// i左边minK的位置</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i]==maxK) r2=i; <span class="comment">// i左边maxK的位置</span></span><br><span class="line">            res+=<span class="built_in">max</span>(<span class="built_in">min</span>(r1,r2)-l,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>







<h1 id="二-不会的题"><a href="#二-不会的题" class="headerlink" title="二. 不会的题"></a>二. 不会的题</h1><h2 id="双指针-1"><a href="#双指针-1" class="headerlink" title="双指针"></a>双指针</h2><h3 id="盛最多水的容器"><a href="#盛最多水的容器" class="headerlink" title="盛最多水的容器"></a>盛最多水的容器</h3><p><code>link:https://leetcode.cn/problems/container-with-most-water/</code></p>
<img src="/post/dd65d9fe/image-20220916133723140.png" alt="image-20220916133723140" style="zoom:50%;">



<p><code>题解</code></p>
<img src="/post/dd65d9fe/image-20220916133933613.png" class title="image-20220916133933613">



<p><code>code</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n=a.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>,j=n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            res=<span class="built_in">max</span>(res,(j-i)*<span class="built_in">min</span>(a[i],a[j]));</span><br><span class="line">            <span class="keyword">if</span>(a[i]&gt;a[j]) j--;</span><br><span class="line">            <span class="keyword">else</span> i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="dp-1"><a href="#dp-1" class="headerlink" title="dp"></a>dp</h2><h3 id="青蛙过河"><a href="#青蛙过河" class="headerlink" title="青蛙过河"></a>青蛙过河</h3><p><code>link:https://leetcode.cn/problems/frog-jump/</code></p>
<img src="/post/dd65d9fe/image-20220919152814293.png" alt="image-20220919152814293" style="zoom:50%;">



<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 题解：dp</span></span><br><span class="line"><span class="section"># 令dp[<span class="string">i</span>][<span class="symbol">j</span>]表示从上一步跳j步到第i个石头是否可行,那么就枚举跳过来的点，根据两点的距离然后判断是否满足条件</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">bool</span> dp[<span class="number">2020</span>][<span class="number">2020</span>]; <span class="comment">//dp[i][j]表示跳j步到i</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canCross</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=a.<span class="built_in">size</span>();</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="type">int</span> len=a[i]-a[j];</span><br><span class="line">                <span class="keyword">if</span>(len&gt;=n) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(dp[j][len+<span class="number">1</span>] || dp[j][len] || dp[j][len<span class="number">-1</span>]) dp[i][len]=<span class="number">1</span>; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[n<span class="number">-1</span>][i]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="戳气球"><a href="#戳气球" class="headerlink" title="戳气球"></a>戳气球</h3><p><code>link:https://leetcode.cn/problems/burst-balloons/</code></p>
<img src="/post/dd65d9fe/image-20220919153315363.png" alt="image-20220919153315363" style="zoom:50%;">



<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 题解:区间dp</span></span><br><span class="line"><span class="section"># 令dp[<span class="string">i</span>][<span class="symbol">j</span>]表示把[<span class="string">i,j</span>]全删完获得的最大值,然后从[<span class="string">i,j</span>]中枚举要删掉的点，因为[<span class="string">i,j</span>]已经删完了,所以区间答案要加	 上a[<span class="string">mid</span>]<span class="emphasis">*a[<span class="string">l-1</span>]*</span>a[<span class="string">r+1</span>],即dp[<span class="string">i</span>][<span class="symbol">j</span>]=dp[<span class="string">i</span>][<span class="symbol">mid-1</span>]+dp[<span class="string">mid+1</span>][<span class="symbol">r</span>]+a[mid]<span class="emphasis">*a[l-1]*</span>a[r+1]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> dp[<span class="number">310</span>][<span class="number">310</span>]; <span class="comment">// dp[i][j]表示把[i,j]全删完获得的最大值</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxCoins</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=a.<span class="built_in">size</span>();</span><br><span class="line">        a.<span class="built_in">insert</span>(a.<span class="built_in">begin</span>(),<span class="number">1</span>);</span><br><span class="line">        a.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 枚举区间长度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">1</span>;len&lt;=n;len++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>;l+len<span class="number">-1</span>&lt;=n;l++)&#123;</span><br><span class="line">                <span class="type">int</span> r=l+len<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">if</span>(l==r) dp[l][r]=a[l]*a[l<span class="number">-1</span>]*a[r+<span class="number">1</span>]; <span class="comment">// 只把这个点删了</span></span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> mid=l;mid&lt;=r;mid++)&#123;</span><br><span class="line">                        <span class="comment">// 接下来删的是mid这个点，因为[l,mid-1]和[mid+1,r]已经删完了</span></span><br><span class="line">                        <span class="comment">// [l,r]只剩下mid这个点，所以a[mid]*a[l-1]*a[r+1]</span></span><br><span class="line">                        dp[l][r]=<span class="built_in">max</span>(dp[l][r],dp[l][mid<span class="number">-1</span>]+dp[mid+<span class="number">1</span>][r]+a[mid]*a[l<span class="number">-1</span>]*a[r+<span class="number">1</span>]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="交错字符串"><a href="#交错字符串" class="headerlink" title="交错字符串"></a>交错字符串</h3><p><code>link:https://leetcode.cn/problems/interleaving-string/</code></p>
<img src="/post/dd65d9fe/image-20220922191613786.png" alt="image-20220922191613786" style="zoom:50%;">



<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 题解:dp</span></span><br><span class="line"><span class="section"># 令dp[<span class="string">i</span>][<span class="symbol">j</span>]表示能否由s1的前i个和s2的前j个构成s3的前i+j个</span></span><br><span class="line"><span class="section"># 若s3[<span class="string">i+j</span>]由s1构成，则要满足dp[<span class="string">i-1</span>][<span class="symbol">j</span>]=true &amp;&amp; s1[i]==s3[i+j]</span></span><br><span class="line"><span class="section"># 若s3[<span class="string">i+j</span>]由s2构成，则要满足dp[<span class="string">i</span>][<span class="symbol">j-1</span>]==true &amp;&amp; s2[j]==s3[i+j]</span></span><br></pre></td></tr></table></figure>

<p><code>code</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">bool</span> dp[<span class="number">210</span>][<span class="number">210</span>];</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isInterleave</span><span class="params">(string s1, string s2, string s3)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1.<span class="built_in">length</span>()+s2.<span class="built_in">length</span>()!=s3.<span class="built_in">length</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(s1==<span class="string">&quot;&quot;</span> &amp;&amp; s2==<span class="string">&quot;&quot;</span> &amp;&amp; s3==<span class="string">&quot;&quot;</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> n=s1.<span class="built_in">size</span>(),m=s2.<span class="built_in">size</span>();</span><br><span class="line">        s1.<span class="built_in">insert</span>(s1.<span class="built_in">begin</span>(),<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">        s2.<span class="built_in">insert</span>(s2.<span class="built_in">begin</span>(),<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">        s3.<span class="built_in">insert</span>(s3.<span class="built_in">begin</span>(),<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) dp[i][<span class="number">0</span>]=(dp[i<span class="number">-1</span>][<span class="number">0</span>] &amp;&amp; s1[i]==s3[i]);<span class="comment">// 处理边界</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) dp[<span class="number">0</span>][i]=(dp[<span class="number">0</span>][i<span class="number">-1</span>] &amp;&amp; s2[i]==s3[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                <span class="comment">// 用s1去凑</span></span><br><span class="line">                <span class="keyword">if</span>(dp[i<span class="number">-1</span>][j] &amp;&amp; s1[i]==s3[i+j]) dp[i][j]=<span class="literal">true</span>;</span><br><span class="line">                <span class="comment">// 用s2去凑</span></span><br><span class="line">                <span class="keyword">if</span>(dp[i][j<span class="number">-1</span>] &amp;&amp; s2[j]==s3[i+j]) dp[i][j]=<span class="literal">true</span>; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="知道秘密的人数"><a href="#知道秘密的人数" class="headerlink" title="知道秘密的人数"></a>知道秘密的人数</h3><p><code>link:https://leetcode.cn/problems/number-of-people-aware-of-a-secret/</code></p>
<img src="/post/dd65d9fe/image-20220924124950099.png" alt="image-20220924124950099" style="zoom:50%;">

<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 题解:dp</span></span><br><span class="line"><span class="section"># 设dp[i]为第i天知道秘密的新人，然后顺着dp就好了，其实这题不难，不知道为什么写不出来...</span></span><br></pre></td></tr></table></figure>

<p><code>code</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line">LL mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LL dp[<span class="number">1010</span>]; <span class="comment">// dp[i]表示第i天有多少个新的人知道秘密</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peopleAwareOfSecret</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> delay, <span class="type">int</span> forget)</span> </span>&#123;</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="built_in">max</span>(<span class="number">1</span>,i-forget+<span class="number">1</span>);j&lt;=i-delay;j++)&#123;</span><br><span class="line">                dp[i]+=dp[j];</span><br><span class="line">                dp[i]%=mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        LL res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="built_in">max</span>(<span class="number">1</span>,n-forget+<span class="number">1</span>);i--)&#123;</span><br><span class="line">            res+=dp[i];</span><br><span class="line">            res%=mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="丑数II"><a href="#丑数II" class="headerlink" title="丑数II"></a>丑数II</h3><p><code>link:https://leetcode.cn/problems/get-kth-magic-number-lcci/</code></p>
<img src="/post/dd65d9fe/image-20220928213555756.png" alt="image-20220928213555756" style="zoom:50%;">

<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 题解:三指针</span></span><br><span class="line"><span class="section"># 每一个数都是由前面的数<span class="emphasis">*2或*</span>3或<span class="emphasis">*7得来的</span></span></span><br><span class="line"><span class="emphasis"><span class="section"># pos2*</span>2表示由第i个数<span class="emphasis">*2得到的数,pos3*</span>3表示由第i个数<span class="emphasis">*3得到的数,pos5*</span>5表示由第i个数<span class="emphasis">*5得到的数</span></span></span><br><span class="line"><span class="emphasis"><span class="section"># min(dp[pos2]*</span>2,min(dp[pos3]<span class="emphasis">*3,dp[pos5]*</span>5))起到排序的作用</span></span><br><span class="line"><span class="section"># 三个if起到去重的作用</span></span><br></pre></td></tr></table></figure>

<p><code>code</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">dp</span>(n+<span class="number">7</span>);</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> pos2=<span class="number">1</span>,pos3=<span class="number">1</span>,pos5=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// pos2专门*2,pos3专门*3,pos5专门*5</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            dp[i]=<span class="built_in">min</span>(dp[pos2]*<span class="number">2</span>,<span class="built_in">min</span>(dp[pos3]*<span class="number">3</span>,dp[pos5]*<span class="number">5</span>)); <span class="comment">// 从小的按顺序转移到大的</span></span><br><span class="line">            <span class="keyword">if</span>(dp[i]==dp[pos2]*<span class="number">2</span>) pos2++; <span class="comment">// dp[pos2]*2这个数有了，转到下个数继续*2</span></span><br><span class="line">            <span class="keyword">if</span>(dp[i]==dp[pos3]*<span class="number">3</span>) pos3++; <span class="comment">// dp[pos3]*3这个数有了，转到下个数继续*3</span></span><br><span class="line">            <span class="keyword">if</span>(dp[i]==dp[pos5]*<span class="number">5</span>) pos5++; <span class="comment">// dp[pos5]*5这个数有了，转到下个数继续*5</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="最长递增子序列II"><a href="#最长递增子序列II" class="headerlink" title="最长递增子序列II"></a>最长递增子序列II</h3><p><code>link:https://leetcode.cn/problems/longest-increasing-subsequence-ii/</code></p>
<img src="/post/dd65d9fe/image-20221014210802278.png" alt="image-20221014210802278" style="zoom:50%;">



<img src="/post/dd65d9fe/typora_image\image-20221014211251787.png" alt="image-20221014211251787" style="zoom: 50%;">

<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 题解: 线段树优化dp</span></span><br><span class="line"><span class="section"># 设dp[i]表示以i结尾的LIS,dp[i]可以从dp[x-k~x-1]转移过来,我们需要在dp[x-k]到dp[x-1]中找一个最大值,然后更新dp[i],找最大值的过程可以用线段树来优化</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> dp[<span class="number">100007</span>]; <span class="comment">// dp[i]表示以i结尾的LIS</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">        <span class="type">int</span> l,r,maxn;</span><br><span class="line">    &#125;seg[<span class="number">100007</span>*<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">        seg[u].maxn=<span class="built_in">max</span>(seg[u&lt;&lt;<span class="number">1</span>].maxn,seg[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].maxn);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l==r) seg[u]=&#123;l,r,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            seg[u]=&#123;l,r&#125;;</span><br><span class="line">            <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">            <span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">            <span class="built_in">pushup</span>(u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(seg[u].l&gt;=l &amp;&amp; seg[u].r&lt;=r) <span class="keyword">return</span> seg[u].maxn;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> mid=seg[u].l+seg[u].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(l&lt;=mid) res=<span class="built_in">query</span>(u&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">            <span class="keyword">if</span>(r&gt;mid) res=<span class="built_in">max</span>(res,<span class="built_in">query</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r));</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> x,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(seg[u].l==x &amp;&amp; seg[u].r==x) seg[u].maxn=v;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> mid=seg[u].l+seg[u].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(x&lt;=mid) <span class="built_in">modify</span>(u&lt;&lt;<span class="number">1</span>,x,v);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">modify</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,x,v);</span><br><span class="line">            <span class="built_in">pushup</span>(u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxn=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:a) maxn=<span class="built_in">max</span>(maxn,x);</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,maxn);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:a)&#123;</span><br><span class="line">            <span class="type">int</span> ans=<span class="built_in">query</span>(<span class="number">1</span>,<span class="built_in">max</span>(<span class="number">1</span>,x-k),x<span class="number">-1</span>);</span><br><span class="line">            dp[x]=ans+<span class="number">1</span>;</span><br><span class="line">            res=<span class="built_in">max</span>(res,dp[x]);</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>,x,dp[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="统计特殊整数-数位dp模板"><a href="#统计特殊整数-数位dp模板" class="headerlink" title="统计特殊整数(数位dp模板)"></a>统计特殊整数(数位dp模板)</h3><p><code>link:https://leetcode.cn/problems/count-special-integers/</code></p>
<img src="/post/dd65d9fe/image-20221018223629082.png" alt="image-20221018223629082" style="zoom:50%;">



<p><code>code</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> dp[<span class="number">50</span>][<span class="number">1</span>&lt;&lt;<span class="number">10</span>];</span><br><span class="line">    string s;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countSpecialNumbers</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        s=<span class="built_in">to_string</span>(n);</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="keyword">sizeof</span> dp);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="literal">true</span>,<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回从pos开始填数字,pos前面的数字集合是mask(二进制),能够构造出的特殊整数数量</span></span><br><span class="line">    <span class="comment">// is_limit表示前面的数字是否都是n对应位上的,如果为true,那么当前位至多为int(s[i]),否则为9</span></span><br><span class="line">    <span class="comment">// is_num表示前面是否填了数字(是否跳过),如果为true,那么当前位可以从0开始,如果为false,那么我们可以跳过,或者从1开始填数字</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos,<span class="type">int</span> mask,<span class="type">bool</span> is_limit,<span class="type">bool</span> is_num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos==s.<span class="built_in">length</span>()) <span class="keyword">return</span> is_num;</span><br><span class="line">        <span class="keyword">if</span>(!is_limit &amp;&amp; is_num &amp;&amp; dp[pos][mask]!=<span class="number">-1</span>) <span class="keyword">return</span> dp[pos][mask];</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 跳过</span></span><br><span class="line">        <span class="keyword">if</span>(!is_num) res=<span class="built_in">dfs</span>(pos+<span class="number">1</span>,mask,<span class="literal">false</span>,<span class="literal">false</span>);</span><br><span class="line">        <span class="type">int</span> up=is_limit?s[pos]-<span class="string">&#x27;0&#x27;</span>:<span class="number">9</span>;</span><br><span class="line">        <span class="comment">// 如果前面数字,可以从0开始,否则从1开始</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=is_num?<span class="number">0</span>:<span class="number">1</span>;i&lt;=up;i++)&#123;</span><br><span class="line">            <span class="comment">// 如果前面没出现i</span></span><br><span class="line">            <span class="keyword">if</span>((mask&gt;&gt;i&amp;<span class="number">1</span>)==<span class="number">0</span>) res+=<span class="built_in">dfs</span>(pos+<span class="number">1</span>,mask|(<span class="number">1</span>&lt;&lt;i),is_limit&amp;&amp;(s[pos]-<span class="string">&#x27;0&#x27;</span>==i),<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!is_limit &amp;&amp; is_num) dp[pos][mask]=res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="字符串的总引力"><a href="#字符串的总引力" class="headerlink" title="字符串的总引力"></a>字符串的总引力</h3><p><code>link:https://leetcode.cn/problems/total-appeal-of-a-string/</code></p>
<p><code>rating:2033</code></p>
<img src="/post/dd65d9fe/image-20221021193243868.png" alt="image-20221021193243868" style="zoom:50%;">



<p><code>题解</code></p>
<img src="/post/dd65d9fe/image-20221021193346183.png" alt="image-20221021193346183" style="zoom:50%;">



<p><code>code</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> last[<span class="number">26</span>];</span><br><span class="line">    LL dp[<span class="number">100010</span>]; <span class="comment">// dp[i]表示以i结尾的子串能得到的总贡献值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">appealSum</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=s.<span class="built_in">size</span>();</span><br><span class="line">        s=<span class="string">&#x27;*&#x27;</span>+s;</span><br><span class="line">        LL res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            dp[i]=dp[i<span class="number">-1</span>]; <span class="comment">// 不考虑第i个字符</span></span><br><span class="line">            dp[i]+=i-last[s[i]-<span class="string">&#x27;a&#x27;</span>]; <span class="comment">// 考虑第i个字符</span></span><br><span class="line">            last[s[i]-<span class="string">&#x27;a&#x27;</span>]=i;</span><br><span class="line">            res+=dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="规划兼职工作"><a href="#规划兼职工作" class="headerlink" title="规划兼职工作"></a>规划兼职工作</h3><p><code>link:https://leetcode.cn/problems/maximum-profit-in-job-scheduling/</code></p>
<img src="/post/dd65d9fe/image-20221022130358516.png" alt="image-20221022130358516" style="zoom:50%;">



<p><code>题解</code></p>
<img src="/post/dd65d9fe/image-20221022130424264.png" class title="image-20221022130424264">

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> dp[<span class="number">50007</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">jobScheduling</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; startTime, vector&lt;<span class="type">int</span>&gt;&amp; endTime, vector&lt;<span class="type">int</span>&gt;&amp; profit)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=startTime.<span class="built_in">size</span>();</span><br><span class="line">        array&lt;<span class="type">int</span>,3&gt;a[n+<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            a[i+<span class="number">1</span>]=&#123;endTime[i],startTime[i],profit[i]&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n,[&amp;](<span class="keyword">auto</span> &amp;x,<span class="keyword">auto</span> &amp;y)&#123;</span><br><span class="line">            <span class="keyword">return</span> x[<span class="number">0</span>]&lt;y[<span class="number">0</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> l=<span class="number">0</span>,r=i<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">                <span class="type">int</span> mid=(l+r+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(a[mid][<span class="number">0</span>]&lt;=a[i][<span class="number">1</span>]) l=mid;</span><br><span class="line">                <span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>],dp[l]+a[i][<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="俄罗斯套娃信封问题"><a href="#俄罗斯套娃信封问题" class="headerlink" title="俄罗斯套娃信封问题"></a>俄罗斯套娃信封问题</h3><p><code>link:https://leetcode.cn/problems/russian-doll-envelopes/</code></p>
<img src="/post/dd65d9fe/image-20221025200716949.png" alt="image-20221025200716949" style="zoom:50%;">



<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 问题本质: 二维LIS</span></span><br></pre></td></tr></table></figure>

<p><code>题解</code></p>
<img src="/post/dd65d9fe/image-20221025200808512.png" class title="image-20221025200808512">

<p><code>做法的妙处: 对高度降序规避了宽度相同的问题,这保证了宽度相同时不会被算入答案,因此只需要看高度即可</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> dp[<span class="number">100007</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxEnvelopes</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>(),[](<span class="keyword">auto</span> &amp;x,<span class="keyword">auto</span> &amp;y)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x[<span class="number">0</span>]==y[<span class="number">0</span>]) <span class="keyword">return</span> x[<span class="number">1</span>]&gt;y[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">return</span> x[<span class="number">0</span>]&lt;y[<span class="number">0</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">int</span> n=a.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> l=<span class="number">0</span>,r=res;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">                <span class="type">int</span> mid=l+r+<span class="number">1</span>&gt;&gt;<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(a[mid][<span class="number">1</span>]&lt;a[i][<span class="number">1</span>]) l=mid;</span><br><span class="line">                <span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[l+<span class="number">1</span>]=i;</span><br><span class="line">            res=<span class="built_in">max</span>(res,l+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxEnvelopes</span><span class="params">(<span class="type">int</span>[][] envelopes)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (envelopes.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> envelopes.length;</span><br><span class="line">        Arrays.sort(envelopes, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] e1, <span class="type">int</span>[] e2)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e1[<span class="number">0</span>] != e2[<span class="number">0</span>]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> e1[<span class="number">0</span>] - e2[<span class="number">0</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> e2[<span class="number">1</span>] - e1[<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] f = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Arrays.fill(f, <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (envelopes[j][<span class="number">1</span>] &lt; envelopes[i][<span class="number">1</span>]) &#123;</span><br><span class="line">                    f[i] = Math.max(f[i], f[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans, f[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="安排邮筒"><a href="#安排邮筒" class="headerlink" title="安排邮筒"></a>安排邮筒</h3><p><code>link:https://leetcode.cn/problems/allocate-mailboxes/description/</code></p>
<img src="/post/dd65d9fe/image-20221110191450338.png" alt="image-20221110191450338" style="zoom:50%;">



<p><code>题解</code></p>
<img src="/post/dd65d9fe/typora_image\image-20221110191523981.png" alt="image-20221110191523981" style="zoom:50%;">

<p><code>code:</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> dp[<span class="number">110</span>][<span class="number">110</span>]; <span class="comment">// dp[i][j]表示在前i个房子放j个邮筒的最小距离总和</span></span><br><span class="line">    <span class="type">int</span> sum[<span class="number">110</span>][<span class="number">110</span>]; <span class="comment">// sum[i][j]表示[i,j]放一个邮筒的最小距离总和</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; houses, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(houses.<span class="built_in">begin</span>(),houses.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dp);</span><br><span class="line">        <span class="type">int</span> n=houses.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++) dp[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">1</span>;len&lt;=n;len++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l+len<span class="number">-1</span>&lt;n;l++)&#123;</span><br><span class="line">                <span class="type">int</span> r=l+len<span class="number">-1</span>;</span><br><span class="line">                <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=l;k&lt;=r;k++) sum[l+<span class="number">1</span>][r+<span class="number">1</span>]+=<span class="built_in">abs</span>(houses[k]-houses[mid]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) dp[i][<span class="number">1</span>]=sum[<span class="number">1</span>][i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=i;k++) dp[i][j]=<span class="built_in">min</span>(dp[i][j],dp[k<span class="number">-1</span>][j<span class="number">-1</span>]+sum[k][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="最小移动总距离"><a href="#最小移动总距离" class="headerlink" title="最小移动总距离"></a>最小移动总距离</h3><p><code>link:https://leetcode.cn/problems/minimum-total-distance-traveled/description/</code></p>
<img src="/post/dd65d9fe/image-20221110195758833-1676634138444.png" alt="image-20221110195758833" style="zoom:50%;">

<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 设dp[<span class="string">i</span>][<span class="symbol">j</span>]表示用前j个工厂修理前i个机器人移动的最小距离</span></span><br><span class="line"><span class="section"># 1.不用第j个工厂:dp[<span class="string">i</span>][<span class="symbol">j</span>]=dp[<span class="string">i</span>][<span class="symbol">j-1</span>]</span></span><br><span class="line"><span class="section"># 2.用第j个工厂:枚举第j个工厂修理机器人的数量,dp[<span class="string">i</span>][<span class="symbol">j</span>]=min(dp[<span class="string">i</span>][<span class="symbol">j</span>],dp[<span class="string">i-k</span>][<span class="symbol">j-1</span>]+cost);</span></span><br><span class="line"><span class="section"># 3.cost可以边转移边计算</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LL dp[<span class="number">110</span>][<span class="number">110</span>]; <span class="comment">// dp[i][j]表示用前j个工厂修理前i个机器人移动的最小距离</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">minimumTotalDistance</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; robot, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; factory)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(robot.<span class="built_in">begin</span>(),robot.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(factory.<span class="built_in">begin</span>(),factory.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> n=robot.<span class="built_in">size</span>(),m=factory.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;i++) dp[<span class="number">0</span>][i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                LL cost=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=<span class="built_in">min</span>(factory[j<span class="number">-1</span>][<span class="number">1</span>],i);k++)&#123;</span><br><span class="line">                    cost+=<span class="built_in">abs</span>(factory[j<span class="number">-1</span>][<span class="number">0</span>]-robot[i-k]); <span class="comment">// k个工厂的距离总和可以在cost中累加</span></span><br><span class="line">                    dp[i][j]=<span class="built_in">min</span>(dp[i][j],dp[i-k][j<span class="number">-1</span>]+cost);</span><br><span class="line">                &#125; </span><br><span class="line">                dp[i][j]=<span class="built_in">min</span>(dp[i][j],dp[i][j<span class="number">-1</span>]); <span class="comment">// 不用第j个工厂</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        LL res=<span class="number">1e18</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) res=<span class="built_in">min</span>(res,dp[n][i]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="多米诺和托米诺平铺"><a href="#多米诺和托米诺平铺" class="headerlink" title="多米诺和托米诺平铺"></a>多米诺和托米诺平铺</h3><p><code>link:https://leetcode.cn/problems/domino-and-tromino-tiling/description/</code></p>
<img src="/post/dd65d9fe/image-20221112134021343.png" alt="image-20221112134021343" style="zoom:50%;">

<p><code>题解</code></p>
<img src="/post/dd65d9fe/image-20221112134102211.png" alt="image-20221112134102211" style="zoom:50%;">

<p><code>code</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">final</span> <span class="type">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line">    <span class="comment">// dp[i][0]代表第i列没铺的合法方案数</span></span><br><span class="line">    <span class="comment">// dp[i][1]代表第i列铺了上面的合法方案数</span></span><br><span class="line">    <span class="comment">// dp[i][2]代表第i列铺了下面的合法方案数</span></span><br><span class="line">    <span class="comment">// dp[i][3]代表第i列上下铺满的合法方案数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">int</span> <span class="title">numTilings</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> dp[][] = <span class="keyword">new</span> <span class="type">long</span>[n+<span class="number">7</span>][<span class="number">4</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">3</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=dp[i<span class="number">-1</span>][<span class="number">3</span>];</span><br><span class="line">            dp[i][<span class="number">1</span>]=(dp[i<span class="number">-1</span>][<span class="number">0</span>]+dp[i<span class="number">-1</span>][<span class="number">2</span>])%mod;</span><br><span class="line">            dp[i][<span class="number">2</span>]=(dp[i<span class="number">-1</span>][<span class="number">0</span>]+dp[i<span class="number">-1</span>][<span class="number">1</span>])%mod;</span><br><span class="line">            dp[i][<span class="number">3</span>]=(dp[i<span class="number">-1</span>][<span class="number">0</span>]+dp[i<span class="number">-1</span>][<span class="number">1</span>]+dp[i<span class="number">-1</span>][<span class="number">2</span>]+dp[i<span class="number">-1</span>][<span class="number">3</span>])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)dp[n][<span class="number">3</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="N次操作后的最大分数和"><a href="#N次操作后的最大分数和" class="headerlink" title="N次操作后的最大分数和"></a>N次操作后的最大分数和</h3><p><code>link:https://leetcode.cn/problems/maximize-score-after-n-operations/</code></p>
<img src="/post/dd65d9fe/image-20221222183301061.png" alt="image-20221222183301061" style="zoom: 67%;">



<p><code>题解</code></p>
<img src="/post/dd65d9fe/typora_image\image-20221222183344386.png" alt="image-20221222183344386" style="zoom:50%;">



<p><code>code</code>	</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> gcd[<span class="number">50</span>][<span class="number">50</span>];</span><br><span class="line">    LL dp[<span class="number">1</span> &lt;&lt; <span class="number">14</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxScore</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i != j) gcd[i][j] = __gcd(nums[i], nums[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        LL res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i++) &#123;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i &gt;&gt; j &amp; <span class="number">1</span>) cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cnt % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(i &gt;&gt; j &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">                            <span class="keyword">if</span>(j != k &amp;&amp; (i &gt;&gt; k &amp; <span class="number">1</span>)) &#123;</span><br><span class="line">                                dp[i] = <span class="built_in">max</span>(dp[i], dp[i ^ (<span class="number">1</span> &lt;&lt; j) ^ (<span class="number">1</span> &lt;&lt; k)] + <span class="number">1LL</span> * cnt / <span class="number">2</span> * gcd[j][k]);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h2 id="贪心-1"><a href="#贪心-1" class="headerlink" title="贪心"></a>贪心</h2><h3 id="无重叠区间"><a href="#无重叠区间" class="headerlink" title="无重叠区间"></a>无重叠区间</h3><p><code>link:https://leetcode.cn/problems/non-overlapping-intervals/</code></p>
<img src="/post/dd65d9fe/image-20220919212531479.png" alt="image-20220919212531479" style="zoom:50%;">



<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 题解：贪心</span></span><br><span class="line"><span class="section"># 若发现a[<span class="string">i</span>][<span class="symbol">0</span>]&gt;a[<span class="string">i-1</span>][<span class="symbol">1</span>]，则res++,更新当前的a[<span class="string">i</span>][<span class="symbol">1</span>],现在的面临的问题是要删哪个区间，显然a[<span class="string">i</span>][<span class="symbol">1</span>]最小越好，所以要删掉右端点较大的区间,所以a[<span class="string">i</span>][<span class="symbol">1</span>]取min(a[<span class="string">i-1</span>][<span class="symbol">1</span>],a[<span class="string">i</span>][<span class="symbol">1</span>])</span></span><br></pre></td></tr></table></figure>

<img src="/post/dd65d9fe/image-20220919212811855.png" class title="image-20220919212811855">



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> n=a.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i][<span class="number">0</span>]&lt;a[i<span class="number">-1</span>][<span class="number">1</span>])&#123;</span><br><span class="line">                res++;</span><br><span class="line">                a[i][<span class="number">1</span>]=<span class="built_in">min</span>(a[i<span class="number">-1</span>][<span class="number">1</span>],a[i][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="加油站"><a href="#加油站" class="headerlink" title="加油站"></a>加油站</h3><p><code>link:https://leetcode.cn/problems/gas-station/</code></p>
<img src="/post/dd65d9fe/image-20220927232450542.png" alt="image-20220927232450542" style="zoom:50%;">

<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 题解:</span></span><br><span class="line"><span class="section"># 从i=0开始走,若发现i走不到i+1,及目前拥有的汽油now&lt;0,则从0-&gt;i任何一个点开始都走不到i,因为0-&gt;i的全过程保证了汽油&gt;=0,加上i点的汽油也走不到i+1,从0-&gt;i任意一个点开始无论如何都走不到i+1,所以起点更新到i+1,在这个过程不断更新起点。最后验证从start-&gt;n-&gt;0-&gt;start-1全过程汽油是否保持&gt;=0</span></span><br></pre></td></tr></table></figure>

<p><code>code</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">canCompleteCircuit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; gas, vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=gas.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> start=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> now=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            now+=gas[i]-cost[i];</span><br><span class="line">            <span class="keyword">if</span>(now&lt;<span class="number">0</span>)&#123; <span class="comment">// i走不到i+1,说明从0-&gt;i任何一个点开始都走不到i+1，起点更新为i+1</span></span><br><span class="line">                now=<span class="number">0</span>;</span><br><span class="line">                start=(i+<span class="number">1</span>)%n;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 验证start这个点行不行的通</span></span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 从start-&gt;n-&gt;0-&gt;start-1,中途的汽油要一直满足&gt;=0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=start;i&lt;n;i++)&#123;</span><br><span class="line">            sum+=gas[i]-cost[i];</span><br><span class="line">            <span class="keyword">if</span>(sum&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;start;i++)&#123;</span><br><span class="line">            sum+=gas[i]-cost[i];</span><br><span class="line">            <span class="keyword">if</span>(sum&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="使数组相等的最小开销"><a href="#使数组相等的最小开销" class="headerlink" title="使数组相等的最小开销"></a>使数组相等的最小开销</h3><p><code>link:https://leetcode.cn/problems/minimum-cost-to-make-array-equal/</code></p>
<img src="/post/dd65d9fe/image-20221023195937900.png" alt="image-20221023195937900" style="zoom:50%;">



<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 这道题是462加强版本</span></span><br><span class="line"><span class="section"># 1.先排序</span></span><br><span class="line"><span class="section"># 2.直接把cost[i]当作有cost[i]个nums[i],然后找中位数,然后就跟462一样了</span></span><br></pre></td></tr></table></figure>

<p><code>code</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">minCost</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        array&lt;<span class="type">int</span>,2&gt;a[n+<span class="number">3</span>]; </span><br><span class="line">        LL sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            a[i+<span class="number">1</span>]=&#123;nums[i],cost[i]&#125;;</span><br><span class="line">            sum+=cost[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n);</span><br><span class="line">        LL middle=sum/<span class="number">2</span>;</span><br><span class="line">        LL cur=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> target;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            cur+=a[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(cur&gt;=middle)&#123;</span><br><span class="line">                target=a[i][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        LL res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            res+=<span class="number">1LL</span>*<span class="built_in">abs</span>(a[i][<span class="number">0</span>]-target)*a[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="自行车拉力赛"><a href="#自行车拉力赛" class="headerlink" title="自行车拉力赛"></a>自行车拉力赛</h3><p><code>link:https://leetcode.cn/contest/espressif-2021/problems/z9nHkj/</code></p>
<img src="/post/dd65d9fe/image-20221028210232187.png" alt="image-20221028210232187" style="zoom:50%;">



<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 题解: 反悔型贪心</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSupplyTimes</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> cur, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());</span><br><span class="line">        priority_queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur&gt;=num) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n=a.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> pos=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(cur&lt;a[i][<span class="number">0</span>]-pos)&#123;</span><br><span class="line">                <span class="keyword">if</span>(q.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                cur+=q.<span class="built_in">top</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">            q.<span class="built_in">push</span>(a[i][<span class="number">1</span>]);</span><br><span class="line">            cur-=(a[i][<span class="number">0</span>]-pos);</span><br><span class="line">            pos=a[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span>(cur&gt;=num-pos) <span class="keyword">return</span> res; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(cur&lt;num-pos)&#123;</span><br><span class="line">            <span class="keyword">if</span>(q.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            cur+=q.<span class="built_in">top</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>







<h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><h3 id="划分为k个相等的子集"><a href="#划分为k个相等的子集" class="headerlink" title="划分为k个相等的子集"></a>划分为k个相等的子集</h3><p><code>link:https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/</code></p>
<img src="/post/dd65d9fe/image-20220922230048588.png" alt="image-20220922230048588" style="zoom:50%;">



<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 爆搜</span></span><br><span class="line"><span class="section"># 设置k个桶，然后从0开始搜索，如果当前桶可以放这个数，那么就放，如果放不了，那么就放下一个桶，以此类推，如果最终这个方案不行就回溯，知道遍历完最后一个数</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> sum;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canPartitionKSubsets</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 优先放大的，填满的快一点</span></span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>(),[&amp;](<span class="type">int</span> x,<span class="type">int</span> y)&#123;</span><br><span class="line">            <span class="keyword">return</span> x&gt;y;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:nums) sum+=x;</span><br><span class="line">        <span class="keyword">if</span>(sum%k!=<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        sum/=k;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">bucket</span>(k);</span><br><span class="line">        n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(nums,bucket,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,vector&lt;<span class="type">int</span>&gt;&amp; bucket,<span class="type">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 如果搜索到index,代表所有数都能够放进桶中，满足条件</span></span><br><span class="line">        <span class="keyword">if</span>(index==n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 遍历每个桶</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;bucket.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="comment">// 剪枝,如果当前桶和上一个桶和相同，那么两个桶得到的结果是一样的</span></span><br><span class="line">            <span class="keyword">if</span>(i &amp;&amp; bucket[i]==bucket[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 和超过了范围</span></span><br><span class="line">            <span class="keyword">if</span>(bucket[i]+nums[index]&gt;sum) <span class="keyword">continue</span>;</span><br><span class="line">            bucket[i]+=nums[index];</span><br><span class="line">            <span class="comment">// 搜索下一个数</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">dfs</span>(nums,bucket,index+<span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            bucket[i]-=nums[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="第K个语法符号"><a href="#第K个语法符号" class="headerlink" title="第K个语法符号"></a>第K个语法符号</h3><p><code>link:</code><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/k-th-symbol-in-grammar/">779. 第K个语法符号 - 力扣（LeetCode）</a></p>
<img src="/post/dd65d9fe/image-20221020123146593.png" alt="image-20221020123146593" style="zoom:50%;">



<p><code>题解</code></p>
<img src="/post/dd65d9fe/typora_image\image-20221020123416702.png" alt="image-20221020123416702" style="zoom:50%;">

<p><code>code</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kthGrammar</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="comment">// 找到他的父亲</span></span><br><span class="line">       <span class="type">int</span> fa=<span class="built_in">kthGrammar</span>(n<span class="number">-1</span>,(k+<span class="number">1</span>)/<span class="number">2</span>); </span><br><span class="line">       <span class="comment">// 如果是左节点,则它跟父亲相同,否则跟父亲相反</span></span><br><span class="line">       <span class="keyword">return</span> k%<span class="number">2</span>==<span class="number">1</span>?fa:!fa;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>code2</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kthGrammar</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">dfs</span>(k<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(k%<span class="number">2</span>==<span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">dfs</span>(k/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> !<span class="built_in">dfs</span>(k/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="获取所有钥匙的最短路径"><a href="#获取所有钥匙的最短路径" class="headerlink" title="获取所有钥匙的最短路径"></a>获取所有钥匙的最短路径</h3><p><code>link:https://leetcode.cn/problems/shortest-path-to-get-all-keys/description/</code></p>
<img src="/post/dd65d9fe/image-20221110165906900.png" alt="image-20221110165906900" style="zoom:50%;">



<p><code>题解</code></p>
<img src="/post/dd65d9fe/image-20221110165932453.png" alt="image-20221110165932453" style="zoom:50%;">

<p><code>code</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>]=&#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,dy[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="type">int</span> dist[<span class="number">35</span>][<span class="number">35</span>][<span class="number">1</span>&lt;&lt;<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">shortestPathAllKeys</span><span class="params">(vector&lt;string&gt;&amp; g)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(dist,<span class="number">-1</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">        <span class="type">int</span> n=g.<span class="built_in">size</span>(),m=g[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        <span class="type">int</span> target=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(g[i][j]==<span class="string">&#x27;@&#x27;</span>)&#123;</span><br><span class="line">                    x=i;</span><br><span class="line">                    y=j;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(g[i][j]&gt;=<span class="string">&#x27;a&#x27;</span> &amp;&amp; g[i][j]&lt;=<span class="string">&#x27;z&#x27;</span>) target |= (<span class="number">1</span>&lt;&lt;(g[i][j]-<span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dist[x][y][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        queue&lt;array&lt;<span class="type">int</span>,3&gt;&gt;q;</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;x,y,<span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">auto</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            x=t[<span class="number">0</span>],y=t[<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> state=t[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">                <span class="type">int</span> tx=x+dx[i],ty=y+dy[i];</span><br><span class="line">                <span class="keyword">if</span>(tx&lt;<span class="number">0</span> || tx&gt;=n || ty&lt;<span class="number">0</span> || ty&gt;=m) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(g[tx][ty]==<span class="string">&#x27;#&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(g[tx][ty]&gt;=<span class="string">&#x27;A&#x27;</span> &amp;&amp; g[tx][ty]&lt;=<span class="string">&#x27;Z&#x27;</span> &amp;&amp; !(state&gt;&gt;(g[tx][ty]-<span class="string">&#x27;A&#x27;</span>)&amp;<span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">int</span> cur=state;</span><br><span class="line">                <span class="keyword">if</span>(g[tx][ty]&gt;=<span class="string">&#x27;a&#x27;</span> &amp;&amp; g[tx][ty]&lt;=<span class="string">&#x27;z&#x27;</span>) cur |= (<span class="number">1</span>&lt;&lt;(g[tx][ty]-<span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">                <span class="keyword">if</span>(dist[tx][ty][cur]!=<span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                dist[tx][ty][cur]=dist[x][y][state]+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(cur==target) <span class="keyword">return</span> dist[tx][ty][cur];</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;tx,ty,cur&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="数组的均值分割"><a href="#数组的均值分割" class="headerlink" title="数组的均值分割"></a>数组的均值分割</h3><p><code>link:https://leetcode.cn/problems/split-array-with-same-average/description/</code></p>
<img src="/post/dd65d9fe/image-20221114152531046.png" alt="image-20221114152531046" style="zoom:50%;">



<p><code>题解</code></p>
<img src="/post/dd65d9fe/image-20221114152618017.png" class title="image-20221114152618017">

<p><code>code</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">splitArraySameAverage</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:a) sum+=x;</span><br><span class="line">        <span class="type">int</span> n=a.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:a) x=x*n-sum;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">bool</span>&gt;mp;</span><br><span class="line">        <span class="type">int</span> m=n/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;(<span class="number">1</span>&lt;&lt;m);i++)&#123;</span><br><span class="line">            <span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&gt;&gt;j&amp;<span class="number">1</span>) s+=a[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            mp[s]=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;(<span class="number">1</span>&lt;&lt;n-m);i++)&#123;</span><br><span class="line">            <span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n-m;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&gt;&gt;j&amp;<span class="number">1</span>) s+=a[j+m];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i!=(<span class="number">1</span>&lt;&lt;n-m)<span class="number">-1</span> &amp;&amp; mp[-s]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 这里解释一下为什么右边不能全选</span></span><br><span class="line">            <span class="comment">// 经过处理后,所有元素的总和为n*sum-n*sum=0,若右边全选,则一定存在唯一的左边子集使得左边加右边的和等于0,即左边全选,这两个是绑定在一起的,所以右边不能全选(题目要求的是真子集,即B数组不能为空)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="树图-1"><a href="#树图-1" class="headerlink" title="树图"></a>树图</h2><h3 id="可能的二分法"><a href="#可能的二分法" class="headerlink" title="可能的二分法"></a>可能的二分法</h3><p><code>link:https://leetcode.cn/problems/possible-bipartition/</code></p>
<img src="/post/dd65d9fe/image-20221016163304988.png" alt="image-20221016163304988" style="zoom:50%;">



<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 题解</span></span><br><span class="line"><span class="section"># 1.二分图</span></span><br><span class="line"></span><br><span class="line"><span class="section"># 2.扩展域并查集:p[i+n]表示i的敌人</span></span><br><span class="line"><span class="section"># 思路: 扩展域并查集可以维护敌人或者更为复杂的关系。一般的并查集都是维护朋友，即两个点在一个分组里。这道题目给的条件是敌人，即[a,b], [a,c] 意味着ab是敌人，ac是敌人，bc必须在一个组里面。所以每个点都抽象出一个反节点(所以总数是2n)。这样就可以通过反节点求出所有的朋友，比如[a,b], [a,c] 那么a+n同时和b和c在一组，也就是敌人的敌人都是朋友。</span></span><br><span class="line"><span class="section"># 假设[a,b],[a,c],则a的敌人是b和c,敌人的敌人是朋友,则b和c为一组,若b和c是敌人,则矛盾,直接return false</span></span><br></pre></td></tr></table></figure>

<p><code>二分图</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> color[<span class="number">2010</span>];</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;g[<span class="number">2010</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">possibleBipartition</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; dislikes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:dislikes)&#123;</span><br><span class="line">            g[x[<span class="number">0</span>]].<span class="built_in">push_back</span>(x[<span class="number">1</span>]);</span><br><span class="line">            g[x[<span class="number">1</span>]].<span class="built_in">push_back</span>(x[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!color[i])&#123;</span><br><span class="line">                <span class="keyword">if</span>(!<span class="built_in">dfs</span>(i,<span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">        color[u]=c;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:g[u])&#123;</span><br><span class="line">            <span class="keyword">if</span>(color[x])&#123;</span><br><span class="line">                <span class="keyword">if</span>(color[x]==color[u]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">dfs</span>(x,<span class="number">3</span>-c)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>扩展域并查集</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> p[<span class="number">4010</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p[u]!=u) p[u]=<span class="built_in">find</span>(p[u]);</span><br><span class="line">        <span class="keyword">return</span> p[u];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">        p[<span class="built_in">find</span>(x)]=<span class="built_in">find</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">possibleBipartition</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; dislikes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++) p[i]=i; <span class="comment">// 扩展域i+n表示i的对立面,即i的敌人</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:dislikes)&#123;</span><br><span class="line">            <span class="type">int</span> a=<span class="built_in">find</span>(x[<span class="number">0</span>]),b=<span class="built_in">find</span>(x[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(a==b) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// x[0]和x[1]即为敌人也为朋友,矛盾</span></span><br><span class="line">             <span class="built_in">merge</span>(x[<span class="number">0</span>],x[<span class="number">1</span>]+n); <span class="comment">// 将x[0]归为x[1]的敌人</span></span><br><span class="line">             <span class="built_in">merge</span>(x[<span class="number">1</span>],x[<span class="number">0</span>]+n); <span class="comment">// 将x[1]归为x[0]的敌人</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="创建价值相同的连通块"><a href="#创建价值相同的连通块" class="headerlink" title="创建价值相同的连通块"></a>创建价值相同的连通块</h3><p><code>link:https://leetcode.cn/problems/create-components-with-same-value/</code></p>
<img src="/post/dd65d9fe/image-20221017201015717.png" alt="image-20221017201015717" style="zoom:50%;">



<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 题解</span></span><br><span class="line"><span class="section"># 1.首先要明确一点,删边数即为删边后的连通块数量-1,只要枚举连通块数量即可</span></span><br><span class="line"><span class="section"># 2.因为每个联通块的价值相等,连通块数<span class="emphasis">*价值=点权和,所以连通块数量为点权和的因子</span></span></span><br><span class="line"><span class="emphasis"><span class="section"># 3.dfs统计每颗子树的大小,若发现子树大小大于target,则直接return -1,若恰好等于target,则直接将这颗子树删掉(即切断与父节点的联系),也就是说这颗子树的点权和=target,可以不用管这颗子树了,继续看其他子树即可</span></span></span><br><span class="line"><span class="emphasis"><span class="section"># 4.道题本质上是统计子树大小的应用</span></span></span><br></pre></td></tr></table></figure>

<p><code>code</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;g[<span class="number">20007</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">componentValue</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:edges)&#123;</span><br><span class="line">            g[x[<span class="number">0</span>]].<span class="built_in">push_back</span>(x[<span class="number">1</span>]);</span><br><span class="line">            g[x[<span class="number">1</span>]].<span class="built_in">push_back</span>(x[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:nums) sum+=x;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res;</span><br><span class="line">        <span class="comment">// 枚举连通块的数量,删边数即为连通块数量-1,连通块数量必须为点权和的因子</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum%i==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">dfs</span>(nums,sum/i,<span class="number">0</span>,<span class="number">-1</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">                    res=i<span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实质为统计子树的点权和或大小</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> target,<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 以该点为祖先的子树的点权和</span></span><br><span class="line">        <span class="type">int</span> ans=nums[u];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;son:g[u])&#123;</span><br><span class="line">            <span class="keyword">if</span>(son==fa) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> ret=<span class="built_in">dfs</span>(nums,target,son,u);</span><br><span class="line">            ans+=ret;</span><br><span class="line">            <span class="keyword">if</span>(ret==<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 子树不满足,整棵树都不满足</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans&gt;target) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 点权和超过目标值</span></span><br><span class="line">        <span class="keyword">if</span>(ans==target) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 满足目标,直接将该点跟父节点的边删掉,这颗子树就不用管了,直接return 0;</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="LCA"><a href="#LCA" class="headerlink" title="LCA"></a>LCA</h3><p><code>link:https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/</code></p>
<img src="/post/dd65d9fe/image-20221029191454973.png" alt="image-20221029191454973" style="zoom:50%;">



<p><code>code</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">// 找到了p或q节点</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val==p-&gt;val || root-&gt;val==q-&gt;val) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode* left=<span class="built_in">lowestCommonAncestor</span>(root-&gt;left,p,q);</span><br><span class="line">        TreeNode* right=<span class="built_in">lowestCommonAncestor</span>(root-&gt;right,p,q);</span><br><span class="line">        <span class="comment">// 如果左右子树找到了p和q,那么它就是LCA,即交叉口的情况</span></span><br><span class="line">        <span class="keyword">if</span>(left &amp;&amp; right) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">// 左边没找到,返回右边,反之返回左边,即一条链上的情况</span></span><br><span class="line">        <span class="keyword">if</span>(!left) <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="从二叉树一个节点到另一个节点每一步的方向"><a href="#从二叉树一个节点到另一个节点每一步的方向" class="headerlink" title="从二叉树一个节点到另一个节点每一步的方向"></a>从二叉树一个节点到另一个节点每一步的方向</h3><p><code>link:https://leetcode.cn/problems/step-by-step-directions-from-a-binary-tree-node-to-another/</code></p>
<img src="/post/dd65d9fe/image-20221029202359824.png" alt="image-20221029202359824" style="zoom:50%;">



<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 题解:</span></span><br><span class="line"><span class="section"># 找到LCA,答案就是从起点到LCA加上从LCA到终点的路径</span></span><br></pre></td></tr></table></figure>

<p><code>code</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> depth;</span><br><span class="line">    string res;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">getDirections</span><span class="params">(TreeNode* root, <span class="type">int</span> startValue, <span class="type">int</span> destValue)</span> </span>&#123;</span><br><span class="line">        TreeNode* lca=<span class="built_in">LCA</span>(root,startValue,destValue);</span><br><span class="line">        <span class="built_in">findDep</span>(lca,startValue,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span>(depth)&#123;</span><br><span class="line">            res+=<span class="string">&#x27;U&#x27;</span>;</span><br><span class="line">            depth--;</span><br><span class="line">        &#125;</span><br><span class="line">        string s;</span><br><span class="line">        <span class="built_in">dfs</span>(lca,destValue,s);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">LCA</span><span class="params">(TreeNode* root,<span class="type">int</span> startValue, <span class="type">int</span> destValue)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val==startValue || root-&gt;val==destValue) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode* left=<span class="built_in">LCA</span>(root-&gt;left,startValue,destValue);</span><br><span class="line">        TreeNode* right=<span class="built_in">LCA</span>(root-&gt;right,startValue,destValue);</span><br><span class="line">        <span class="keyword">if</span>(left &amp;&amp; right) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>(!left) <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root,<span class="type">int</span> destValue,string &amp;s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val==destValue)&#123;</span><br><span class="line">            res+=s;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        s+=<span class="string">&#x27;L&#x27;</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left,destValue,s);</span><br><span class="line">        s.<span class="built_in">pop_back</span>();</span><br><span class="line">        s+=<span class="string">&#x27;R&#x27;</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right,destValue,s);</span><br><span class="line">        <span class="comment">// 最后这里要pop_back()是因为s传的是引用,这里要回溯</span></span><br><span class="line">        s.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">findDep</span><span class="params">(TreeNode* root,<span class="type">int</span> startValue,<span class="type">int</span> dep)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val==startValue)&#123;</span><br><span class="line">            depth=dep;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">findDep</span>(root-&gt;left,startValue,dep+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">findDep</span>(root-&gt;right,startValue,dep+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="移除子树后的二叉树高度"><a href="#移除子树后的二叉树高度" class="headerlink" title="移除子树后的二叉树高度"></a>移除子树后的二叉树高度</h3><p><code>link:https://leetcode.cn/problems/height-of-binary-tree-after-subtree-removal-queries/</code></p>
<img src="/post/dd65d9fe/image-20221102195219541.png" alt="image-20221102195219541" style="zoom:50%;">



<p><code>题解</code></p>
<img src="/post/dd65d9fe/image-20221102195318619.png" class title="image-20221102195318619">



<p><code>code</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> height[<span class="number">100010</span>];</span><br><span class="line">    <span class="type">int</span> res[<span class="number">100010</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">treeQueries</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">get_height</span>(root);</span><br><span class="line">        <span class="built_in">dfs</span>(root,<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:queries) x=res[x];</span><br><span class="line">        <span class="keyword">return</span> queries;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求出所有子树的高度</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_height</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> h=<span class="number">1</span>+<span class="built_in">max</span>(<span class="built_in">get_height</span>(root-&gt;left),<span class="built_in">get_height</span>(root-&gt;right));</span><br><span class="line">        height[root-&gt;val]=h;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root,<span class="type">int</span> depth,<span class="type">int</span> hmax)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        depth++;</span><br><span class="line">        res[root-&gt;val]=hmax;</span><br><span class="line">        <span class="type">int</span> r=root-&gt;right?height[root-&gt;right-&gt;val]:<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> l=root-&gt;left?height[root-&gt;left-&gt;val]:<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 若移除左子树，则高度为之前的高度hmax或当前深度加上右子树的高度</span></span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left,depth,<span class="built_in">max</span>(hmax,depth+r));</span><br><span class="line">        <span class="comment">// 若移除右子树，则高度为之前的高度hmax或当前深度加上左子树的高度</span></span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right,depth,<span class="built_in">max</span>(hmax,depth+l));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="逐层排序二叉树所需的最少操作数目"><a href="#逐层排序二叉树所需的最少操作数目" class="headerlink" title="逐层排序二叉树所需的最少操作数目"></a>逐层排序二叉树所需的最少操作数目</h3><p><code>link:https://leetcode.cn/problems/minimum-number-of-operations-to-sort-a-binary-tree-by-level/description/</code></p>
<img src="/post/dd65d9fe/image-20221113192113687.png" alt="image-20221113192113687" style="zoom:50%;">



<p><code>题解1</code></p>
<img src="/post/dd65d9fe/image-20221113192307576-1676634425942.png" class title="image-20221113192307576">

<img src="/post/dd65d9fe/image-20221113192432870.png" class title="image-20221113192432870">

<p><code>code</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;g[<span class="number">100007</span>];</span><br><span class="line">    <span class="type">int</span> depth;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumOperations</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root,<span class="number">0</span>);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;a;</span><br><span class="line">        <span class="comment">// 离散化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=depth;i++)&#123;</span><br><span class="line">            a.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:g[i]) a.<span class="built_in">push_back</span>(x);</span><br><span class="line">            <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:g[i]) x=<span class="built_in">lower_bound</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>(),x)-a.<span class="built_in">begin</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=depth;i++)&#123;</span><br><span class="line">            vector&lt;<span class="type">bool</span>&gt;<span class="built_in">vis</span>(g[i].<span class="built_in">size</span>());</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;g[i].<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(vis[j]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">                <span class="type">int</span> now=j;</span><br><span class="line">                <span class="keyword">while</span>(!vis[now])&#123;</span><br><span class="line">                    vis[now]=<span class="literal">true</span>;</span><br><span class="line">                    cnt++;</span><br><span class="line">                    now=g[i][now]; <span class="comment">// 跳到下一个点</span></span><br><span class="line">                &#125;</span><br><span class="line">                res+=cnt<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">        depth=<span class="built_in">max</span>(depth,d);</span><br><span class="line">        g[d].<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left) <span class="built_in">dfs</span>(root-&gt;left,d+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right) <span class="built_in">dfs</span>(root-&gt;right,d+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><code>题解2</code></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 假设有cnt个连通块,每个连通块的大小为N1,N2,N3...,则每个连通块的贡献为N1-1,N2-1,N3-1...,则每层的答案为N1-1+N2-1+N3-1+....=n-N,其中N为该层节点的数量,n为连通块的数量,连通块的数量可以通过并查集求</span></span><br></pre></td></tr></table></figure>

<p><code>code</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;g[<span class="number">100007</span>];</span><br><span class="line">    <span class="type">int</span> depth;</span><br><span class="line">    <span class="type">int</span> p[<span class="number">100007</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(u!=p[u]) p[u]=<span class="built_in">find</span>(p[u]);</span><br><span class="line">        <span class="keyword">return</span> p[u];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">        x=<span class="built_in">find</span>(x);</span><br><span class="line">        y=<span class="built_in">find</span>(y);</span><br><span class="line">        p[x]=y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumOperations</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root,<span class="number">0</span>);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;a;</span><br><span class="line">        <span class="comment">// 离散化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=depth;i++)&#123;</span><br><span class="line">            a.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:g[i]) a.<span class="built_in">push_back</span>(x);</span><br><span class="line">            <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:g[i]) x=<span class="built_in">lower_bound</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>(),x)-a.<span class="built_in">begin</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=depth;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;g[i].<span class="built_in">size</span>();j++) p[j]=j;</span><br><span class="line">            <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;g[i].<span class="built_in">size</span>();j++) <span class="built_in">merge</span>(j,g[i][j]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;g[i].<span class="built_in">size</span>();j++) cnt+=(<span class="built_in">find</span>(j)==j);</span><br><span class="line">            res+=g[i].<span class="built_in">size</span>()-cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">        depth=<span class="built_in">max</span>(depth,d);</span><br><span class="line">        g[d].<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left) <span class="built_in">dfs</span>(root-&gt;left,d+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right) <span class="built_in">dfs</span>(root-&gt;right,d+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h2 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="整理书架"><a href="#整理书架" class="headerlink" title="整理书架"></a>整理书架</h3><p><code>link:https://leetcode.cn/contest/tianchi2022/problems/ev2bru/</code></p>
<img src="/post/dd65d9fe/image-20221023194649404.png" class title="image-20221023194649404">



<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 题解:贪心+有限制的单调栈</span></span><br><span class="line"><span class="section"># 1.手玩一下</span></span><br><span class="line"><span class="section"># 2.从左往右遍历,如果找到更小的数字,那么就把前面的更大的数去掉</span></span><br><span class="line"><span class="section"># 3.出现次数大于limit的元素,应该删除直到出现次数等于limit</span></span><br><span class="line"><span class="section"># 4.遍历的同时,保证栈里面的元素的出现次数不超过limit</span></span><br><span class="line"><span class="section"># 5.如果后面没有足够的数字,就无法弹栈</span></span><br><span class="line"><span class="section"># 6.在这个前提下,如果遇到了比栈顶小的元素,就可以出栈了</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>code</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> cnt[<span class="number">1000007</span>];</span><br><span class="line">    <span class="type">int</span> cur[<span class="number">1000007</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arrangeBookshelf</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">int</span> limit)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt;st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:a) cnt[x]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:a)&#123;</span><br><span class="line">            <span class="comment">// 当前这个数的个数已经达到limit,不能再加上去了</span></span><br><span class="line">            <span class="keyword">if</span>(cur[x]==limit)&#123;</span><br><span class="line">                cnt[x]--;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当前这个数的值+1</span></span><br><span class="line">            cur[x]++;</span><br><span class="line">            <span class="keyword">if</span>(!st.<span class="built_in">size</span>()) st.<span class="built_in">push</span>(x);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 贪心:栈顶值大于当前值</span></span><br><span class="line">                <span class="comment">// 若去掉栈顶并且后面的cnt[st.top()]能够满足limit这个条件,那么就弹栈</span></span><br><span class="line">                <span class="comment">// 要满足cnt[st.top()]+cur[st.top()]&gt;limit</span></span><br><span class="line">                <span class="keyword">while</span>(st.<span class="built_in">size</span>() &amp;&amp; st.<span class="built_in">top</span>()&gt;x &amp;&amp; cnt[st.<span class="built_in">top</span>()]&gt;limit-cur[st.<span class="built_in">top</span>()])&#123;</span><br><span class="line">                    cur[st.<span class="built_in">top</span>()]--;</span><br><span class="line">                    st.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                st.<span class="built_in">push</span>(x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 注意个数要减少</span></span><br><span class="line">            cnt[x]--;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;res;</span><br><span class="line">        <span class="keyword">while</span>(st.<span class="built_in">size</span>())&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(st.<span class="built_in">top</span>());</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="绝对差不超过限制的最长连续子数组"><a href="#绝对差不超过限制的最长连续子数组" class="headerlink" title="绝对差不超过限制的最长连续子数组"></a>绝对差不超过限制的最长连续子数组</h3><p><code>link:https://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/</code></p>
<img src="/post/dd65d9fe/image-20221026181857782.png" alt="image-20221026181857782" style="zoom:50%;">



<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 题解: 我们可以枚举每一个位置作为右端点，找到其对应的最靠左的左端点，满足区间中最大值与最小值的差不超过</span></span><br><span class="line"><span class="section"># 注意到随着右端点向右移动，左端点也将向右移动，于是我们可以使用滑动窗口解决本题。</span></span><br><span class="line">1.用set</span><br><span class="line">2.维护两个单调队列</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>set</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestSubarray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> limit)</span> </span>&#123;</span><br><span class="line">        multiset&lt;<span class="type">int</span>&gt;s;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>,l=<span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(r&lt;n)&#123;</span><br><span class="line">            s.<span class="built_in">insert</span>(nums[r]);</span><br><span class="line">            <span class="keyword">while</span>(s.<span class="built_in">size</span>() &amp;&amp; *s.<span class="built_in">rbegin</span>()-*s.<span class="built_in">begin</span>()&gt;limit) s.<span class="built_in">erase</span>(s.<span class="built_in">find</span>(nums[l++]));</span><br><span class="line">            res=<span class="built_in">max</span>(res,r-l+<span class="number">1</span>);</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>单调队列</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestSubarray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> limit)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>,l=<span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        deque&lt;<span class="type">int</span>&gt;qmax;</span><br><span class="line">        deque&lt;<span class="type">int</span>&gt;qmin;</span><br><span class="line">        <span class="keyword">while</span>(r&lt;n)&#123;</span><br><span class="line">            <span class="keyword">while</span>(qmax.<span class="built_in">size</span>() &amp;&amp; nums[r]&gt;nums[qmax.<span class="built_in">back</span>()]) qmax.<span class="built_in">pop_back</span>();</span><br><span class="line">            <span class="keyword">while</span>(qmin.<span class="built_in">size</span>() &amp;&amp; nums[r]&lt;nums[qmin.<span class="built_in">back</span>()]) qmin.<span class="built_in">pop_back</span>();</span><br><span class="line">            qmax.<span class="built_in">push_back</span>(r); <span class="comment">// 因为min和max可能是是num[r]，所以要先把r放进队列</span></span><br><span class="line">            qmin.<span class="built_in">push_back</span>(r);</span><br><span class="line">            <span class="keyword">while</span>(qmax.<span class="built_in">size</span>() &amp;&amp; qmin.<span class="built_in">size</span>() &amp;&amp; nums[qmax.<span class="built_in">front</span>()]-nums[qmin.<span class="built_in">front</span>()]&gt;limit)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[qmax.<span class="built_in">front</span>()]==nums[l]) qmax.<span class="built_in">pop_front</span>(); <span class="comment">// 只需要看min和max，其他值不用管</span></span><br><span class="line">                <span class="keyword">if</span>(nums[qmin.<span class="built_in">front</span>()]==nums[l]) qmin.<span class="built_in">pop_front</span>();</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            res=<span class="built_in">max</span>(res,r-l+<span class="number">1</span>);</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="子数组的最小值之和"><a href="#子数组的最小值之和" class="headerlink" title="子数组的最小值之和"></a>子数组的最小值之和</h3><p><code>link:https://leetcode.cn/problems/sum-of-subarray-minimums/</code></p>
<img src="/post/dd65d9fe/image-20221028133643647.png" alt="image-20221028133643647" style="zoom:50%;">



<p><code>题解</code></p>
<blockquote>
<p>若这题改称子数组，则用单调栈扫四次即可</p>
</blockquote>
<img src="/post/dd65d9fe/image-20221028133746720.png" class title="image-20221028133746720">

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line">LL mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> left[<span class="number">30007</span>];</span><br><span class="line">    <span class="type">int</span> right[<span class="number">30007</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumSubarrayMins</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=a.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            left[i]=<span class="number">-1</span>;</span><br><span class="line">            right[i]=n;</span><br><span class="line">        &#125;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt;st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(st.<span class="built_in">size</span>() &amp;&amp; a[st.<span class="built_in">top</span>()]&gt;=a[i]) st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(st.<span class="built_in">size</span>()) left[i]=st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(st.<span class="built_in">size</span>()) st.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">while</span>(st.<span class="built_in">size</span>() &amp;&amp; a[st.<span class="built_in">top</span>()]&gt;a[i]) st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(st.<span class="built_in">size</span>()) right[i]=st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        LL res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            res+=<span class="number">1LL</span>*(i-left[i])*(right[i]-i)*a[i];</span><br><span class="line">            res%=mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// for(int i=0;i&lt;n;i++) cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; left[i] &lt;&lt; &quot; &quot; &lt;&lt; right[i] &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="下一个更大元素IV"><a href="#下一个更大元素IV" class="headerlink" title="下一个更大元素IV"></a>下一个更大元素IV</h3><p><code>link:https://leetcode.cn/problems/next-greater-element-iv/</code></p>
<img src="/post/dd65d9fe/image-20221102184819825.png" alt="image-20221102184819825" style="zoom:50%;">



<p><code>题意: 找到每个数右边第二个比它大的元素</code></p>
<p><code>法1</code></p>
<img src="/post/dd65d9fe/image-20221102185111671.png" class title="image-20221102185111671">

<p><code>code</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">secondGreaterElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;PII&gt;a;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) a.<span class="built_in">push_back</span>(&#123;nums[i],i&#125;);</span><br><span class="line">        <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>(),[](<span class="keyword">auto</span> &amp;x,<span class="keyword">auto</span> &amp;y)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x.first==y.first) <span class="keyword">return</span> x.second&lt;y.second;</span><br><span class="line">            <span class="keyword">return</span> x.first&gt;y.first;</span><br><span class="line">        &#125;);       </span><br><span class="line">        set&lt;<span class="type">int</span>&gt;s;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">res</span>(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> cur=a[i].second;</span><br><span class="line">            <span class="keyword">auto</span> it=s.<span class="built_in">lower_bound</span>(cur);</span><br><span class="line">            <span class="keyword">if</span>(it==s.<span class="built_in">end</span>()) res[cur]=<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                it++;</span><br><span class="line">                <span class="keyword">if</span>(it==s.<span class="built_in">end</span>()) res[cur]=<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">else</span> res[cur]=nums[*it];</span><br><span class="line">            &#125;</span><br><span class="line">            s.<span class="built_in">insert</span>(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>法2</code></p>
<img src="/post/dd65d9fe/image-20230105171133552.png" class title="image-20230105171133552">

<p><code>code</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">secondGreaterElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; se;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; fi;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(se.<span class="built_in">size</span>() &amp;&amp; nums[se.<span class="built_in">top</span>()] &lt; nums[i]) &#123;</span><br><span class="line">                res[se.<span class="built_in">top</span>()] = nums[i];</span><br><span class="line">                se.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(fi.<span class="built_in">size</span>() &amp;&amp; nums[fi.<span class="built_in">top</span>()] &lt; nums[i]) &#123;</span><br><span class="line">                temp.<span class="built_in">push</span>(fi.<span class="built_in">top</span>());</span><br><span class="line">                fi.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 开多一个栈是为了保持先后顺序</span></span><br><span class="line">            <span class="keyword">while</span>(temp.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                se.<span class="built_in">push</span>(temp.<span class="built_in">top</span>());</span><br><span class="line">                temp.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            fi.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>







<h3 id="单线程CPU"><a href="#单线程CPU" class="headerlink" title="单线程CPU"></a>单线程CPU</h3><p><code>link:https://leetcode.cn/problems/single-threaded-cpu/</code></p>
<img src="/post/dd65d9fe/image-20221105133303967.png" alt="image-20221105133303967" style="zoom:50%;">



<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1.将原数组转化为三元组,按照入队时间从小到大排序</span></span><br><span class="line"><span class="section"># 2.用小根堆保存每个任务的执行时间和下标,按照执行之间升序,下标升序</span></span><br><span class="line"><span class="section"># 3.根据当前时间将符合的任务入队,如果队列为空,则将当前任务入队,更新当前时间</span></span><br><span class="line"><span class="section"># 4.每次都将堆顶弹出,加入到答案中去,然后更新当前时间</span></span><br></pre></td></tr></table></figure>

<img src="/post/dd65d9fe/image-20221105133824773.png" class title="image-20221105133824773">



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getOrder</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; tasks)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n=tasks.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;res;</span><br><span class="line">        vector&lt;array&lt;<span class="type">int</span>,3&gt;&gt;a;</span><br><span class="line">        LL ed=<span class="number">1e9</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            a.<span class="built_in">push_back</span>(&#123;tasks[i][<span class="number">0</span>],tasks[i][<span class="number">1</span>],i&#125;);</span><br><span class="line">            ed=<span class="built_in">min</span>(ed,<span class="number">1LL</span>*tasks[i][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());</span><br><span class="line">        priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt;q;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cnt&lt;n)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;n &amp;&amp; a[i][<span class="number">0</span>]&lt;=ed)&#123;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;a[i][<span class="number">1</span>],a[i][<span class="number">2</span>]&#125;);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;n &amp;&amp; q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;a[i][<span class="number">1</span>],a[i][<span class="number">2</span>]&#125;);</span><br><span class="line">                ed=a[i][<span class="number">0</span>];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">auto</span> t=q.<span class="built_in">top</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            cnt++;</span><br><span class="line">            res.<span class="built_in">push_back</span>(t.second);</span><br><span class="line">            ed+=t.first;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h2 id="思维"><a href="#思维" class="headerlink" title="思维"></a>思维</h2><h3 id="黑白棋游戏"><a href="#黑白棋游戏" class="headerlink" title="黑白棋游戏"></a>黑白棋游戏</h3><p><code>link:https://leetcode.cn/contest/zj-future2022/problems/GVbKaI/</code></p>
<img src="/post/dd65d9fe/image-20221027173400446.png" class title="image-20221027173400446">

<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 思路：</span></span><br><span class="line"><span class="section"># 通过滑动窗口的思想。</span></span><br><span class="line"><span class="section"># 观察例子可以看到，最后所有的1都会在一起，窗口的大小为1的个数之和。</span></span><br><span class="line"><span class="section"># 我们通过窗口内，如果1的个数最多，0的个数最小，那么此时需要交换的次数就是最少的。也就是交换次数==窗口大小-窗口内1的个数。</span></span><br></pre></td></tr></table></figure>

<p><code>code</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> sum[<span class="number">100007</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSwaps</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; chess)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=chess.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) sum[i+<span class="number">1</span>]=sum[i]+(chess[i]==<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> k=sum[n];</span><br><span class="line">        <span class="type">int</span> res=<span class="number">1e9</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=k;i&lt;=n;i++) res=<span class="built_in">min</span>(res,k-(sum[i]-sum[i-k]));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="子序列宽度之和"><a href="#子序列宽度之和" class="headerlink" title="子序列宽度之和"></a>子序列宽度之和</h3><p><code>link:https://leetcode.cn/problems/sum-of-subsequence-widths/description/</code></p>
<img src="/post/dd65d9fe/image-20221118110833360.png" alt="image-20221118110833360" style="zoom:50%;">

<p><code>题解</code></p>
<img src="/post/dd65d9fe/1668675423-JpuPGp-891.png" class title="1668675423-JpuPGp-891">

<p><code>code</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LL mod = <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">LL <span class="title">qmi</span><span class="params">(LL x, LL k)</span></span>&#123;</span><br><span class="line">        LL res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(k)&#123;</span><br><span class="line">            <span class="keyword">if</span>(k &amp; <span class="number">1</span>) res = (res * x) % mod;</span><br><span class="line">            k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            x = (x * x) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumSubseqWidths</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        LL res  = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">            res = (res + nums[i] * (<span class="built_in">qmi</span>(<span class="number">2</span>, i) - <span class="built_in">qmi</span>(<span class="number">2</span>, n - i - <span class="number">1</span>))) % mod;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> (res % mod + mod % mod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><h3 id="878-第-N-个神奇数字-力扣（LeetCode）"><a href="#878-第-N-个神奇数字-力扣（LeetCode）" class="headerlink" title="878. 第 N 个神奇数字 - 力扣（LeetCode）"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/nth-magical-number/">878. 第 N 个神奇数字 - 力扣（LeetCode）</a></h3><img src="/post/dd65d9fe/image-20221201012716027.png" alt="image-20221201012716027" style="zoom:50%;">

<p><code>题解</code></p>
<img src="/post/dd65d9fe/1669032532-GjXsyF-878-2.png" alt="1669032532-GjXsyF-878-2" style="zoom:50%;">

<p><code>code</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LL mod = <span class="number">1000000000</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">nthMagicalNumber</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        LL l = <span class="number">1</span>, r = <span class="number">1e18</span>;</span><br><span class="line">        <span class="type">int</span> lcm = a * b / __gcd(a, b);</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            LL mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            LL ans = mid / a + mid / b - mid / lcm;</span><br><span class="line">            <span class="keyword">if</span>(ans &gt;= n) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (l + mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="枚举优化"><a href="#枚举优化" class="headerlink" title="枚举优化"></a>枚举优化</h2><h3 id="统计上升四元组"><a href="#统计上升四元组" class="headerlink" title="统计上升四元组"></a>统计上升四元组</h3><p><code>link:https://leetcode.cn/problems/count-increasing-quadruplets/</code></p>
<img src="/post/dd65d9fe/image-20230202182330790.png" class title="image-20230202182330790">

<p><code>题解</code></p>
<img src="/post/dd65d9fe/image-20230202182410685.png" class title="image-20230202182410685">

<p><code>code</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> great[<span class="number">4001</span>][<span class="number">4001</span>];</span><br><span class="line">    <span class="type">int</span> less[<span class="number">4001</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">countQuadruplets</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = (<span class="type">int</span>)a.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) great[i][j] = great[i + <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = a[i + <span class="number">1</span>] - <span class="number">1</span>; j &gt;= <span class="number">1</span>; j--) great[i][j]++;</span><br><span class="line">        &#125;</span><br><span class="line">        LL res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; n - <span class="number">2</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> x = a[j - <span class="number">1</span>] + <span class="number">1</span>; x &lt;= n; x++) less[x]++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = j + <span class="number">1</span>; k &lt; n - <span class="number">1</span>; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(a[j] &gt; a[k]) res += <span class="number">1LL</span> * great[k][a[j]] * less[a[k]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="博弈"><a href="#博弈" class="headerlink" title="博弈"></a>博弈</h2><h3 id="石子游戏VII"><a href="#石子游戏VII" class="headerlink" title="石子游戏VII"></a>石子游戏VII</h3><p><code>link:https://leetcode.cn/problems/stone-game-vii/</code></p>
<p><code>题解</code></p>
<img src="/post/dd65d9fe/image-20230205214032072.png" class title="image-20230205214032072">

<p><code>code</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> dp[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line">    <span class="type">int</span> sum[<span class="number">1010</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">stoneGameVII</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = (<span class="type">int</span>)a.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) sum[i + <span class="number">1</span>] = sum[i] + a[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> len = <span class="number">1</span>; len &lt;= n; len++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i + len - <span class="number">1</span> &lt;= n; i++) &#123;</span><br><span class="line">                <span class="type">int</span> j = i + len - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(len == <span class="number">1</span>) dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">2</span>) dp[i][j] = <span class="built_in">max</span>(a[i - <span class="number">1</span>], a[j - <span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = <span class="built_in">max</span>(sum[j] - sum[i] - dp[i + <span class="number">1</span>][j], sum[j - <span class="number">1</span>] - sum[i - <span class="number">1</span>] - dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h1 id="三-面试笔试题"><a href="#三-面试笔试题" class="headerlink" title="三. 面试笔试题"></a>三. 面试笔试题</h1><h2 id="思维-1"><a href="#思维-1" class="headerlink" title="思维"></a>思维</h2><h3 id="1-轮转数组"><a href="#1-轮转数组" class="headerlink" title="1. 轮转数组"></a>1. 轮转数组</h3><p><code>link:https://leetcode.cn/problems/rotate-array/</code></p>
<img src="/post/dd65d9fe/image-20221013130418398.png" alt="image-20221013130418398" style="zoom:50%;">



<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 题解</span></span><br><span class="line"><span class="section"># nums = &quot;-----&gt;--&gt;&quot;; k =3</span></span><br><span class="line"><span class="section"># result = &quot;--&gt;-----&gt;&quot;;</span></span><br><span class="line"></span><br><span class="line"><span class="section"># reverse &quot;-----&gt;--&gt;&quot; we can get &quot;&lt;--&lt;-----&quot;</span></span><br><span class="line"><span class="section"># reverse &quot;&lt;--&quot; we can get &quot;--&gt;&lt;-----&quot;</span></span><br><span class="line"><span class="section"># reverse &quot;&lt;-----&quot; we can get &quot;--&gt;-----&gt;&quot;</span></span><br><span class="line"><span class="section"># this visualization help me figure it out :)</span></span><br></pre></td></tr></table></figure>

<p><code>code</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums[l],nums[r]);</span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        n=nums.<span class="built_in">size</span>();</span><br><span class="line">        k%=n;</span><br><span class="line">        <span class="built_in">reverse</span>(nums,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">reverse</span>(nums,<span class="number">0</span>,k<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">reverse</span>(nums,k,n<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><blockquote>
<p>以后有形如t-&gt;next，首先要判断t是否为空！</p>
</blockquote>
<h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h3><p><code>link:https://leetcode.cn/problems/UHnkqh/</code></p>
<img src="/post/dd65d9fe/image-20221013152145057.png" alt="image-20221013152145057" style="zoom:50%;">



<p><code>code</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* pre=<span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* cur=head;</span><br><span class="line">        <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">            ListNode* next=cur-&gt;next;</span><br><span class="line">            cur-&gt;next=pre;</span><br><span class="line">            pre=cur;</span><br><span class="line">            cur=next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>递归写法</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reverse</span>(<span class="literal">nullptr</span>,head);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* pre,ListNode* cur)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur==<span class="literal">nullptr</span>) <span class="keyword">return</span> pre;</span><br><span class="line">        ListNode* next=cur-&gt;next;</span><br><span class="line">        cur-&gt;next=pre;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reverse</span>(cur,next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="删除排序链表中的重复元素"><a href="#删除排序链表中的重复元素" class="headerlink" title="删除排序链表中的重复元素"></a>删除排序链表中的重复元素</h3><p><code>link:https://leetcode.cn/problems/remove-duplicates-from-sorted-list/</code></p>
<img src="/post/dd65d9fe/image-20221013154216397.png" alt="image-20221013154216397" style="zoom:50%;">



<p><code>code</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span> || head-&gt;next==<span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* pre=head;</span><br><span class="line">        ListNode* cur=head-&gt;next;</span><br><span class="line">        <span class="type">int</span> t;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pre-&gt;val==cur-&gt;val)&#123;</span><br><span class="line">                t=pre-&gt;val;</span><br><span class="line">                <span class="keyword">while</span>(cur!=<span class="literal">nullptr</span> &amp;&amp; cur-&gt;val==t) cur=cur-&gt;next;</span><br><span class="line">                pre-&gt;next=cur;</span><br><span class="line">                pre=cur;</span><br><span class="line">                <span class="keyword">if</span>(cur!=<span class="literal">nullptr</span>) cur=cur-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                pre=cur;</span><br><span class="line">                cur=cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="删除排序链表中的重复元素II"><a href="#删除排序链表中的重复元素II" class="headerlink" title="删除排序链表中的重复元素II"></a>删除排序链表中的重复元素II</h3><p><code>link:https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/</code></p>
<img src="/post/dd65d9fe/image-20221013163325426.png" alt="image-20221013163325426" style="zoom:50%;">



<p><code>code</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span> || head-&gt;next==<span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* vir=<span class="literal">nullptr</span>; <span class="comment">// 虚拟头节点</span></span><br><span class="line">        ListNode* cur=head,*last=head-&gt;next;</span><br><span class="line">        <span class="type">int</span> t;</span><br><span class="line">        <span class="keyword">while</span>(last!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(last!=<span class="literal">nullptr</span> &amp;&amp; cur-&gt;val==last-&gt;val)&#123;</span><br><span class="line">                t=cur-&gt;val;</span><br><span class="line">                <span class="keyword">while</span>(last!=<span class="literal">nullptr</span> &amp;&amp; last-&gt;val==t) last=last-&gt;next;</span><br><span class="line">                cur=last;</span><br><span class="line">                <span class="keyword">if</span>(last!=<span class="literal">nullptr</span>) last=last-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(vir==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                vir=cur;</span><br><span class="line">                head=cur;</span><br><span class="line">                <span class="keyword">if</span>(vir!=<span class="literal">nullptr</span>) vir-&gt;next=last;</span><br><span class="line">                cur=last;</span><br><span class="line">                <span class="keyword">if</span>(cur!=<span class="literal">nullptr</span>) last=cur-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                head-&gt;next=cur;</span><br><span class="line">                head=cur;</span><br><span class="line">                cur=last;</span><br><span class="line">                <span class="keyword">if</span>(cur!=<span class="literal">nullptr</span>) last=cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vir;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="链表中倒数第k个节点"><a href="#链表中倒数第k个节点" class="headerlink" title="链表中倒数第k个节点"></a>链表中倒数第k个节点</h3><p><code>link:https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/</code></p>
<img src="/post/dd65d9fe/image-20221013172849220.png" alt="image-20221013172849220" style="zoom:50%;">



<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 题解</span></span><br><span class="line"><span class="section"># 1.遍历两次</span></span><br><span class="line"></span><br><span class="line"><span class="section"># 2.快慢指针</span></span><br><span class="line"><span class="section"># 倒数第k个就是正数第n+1-k个,即慢指针slow要走n-k步,可以先让快指针fast先走k步,则快指针还剩n-k步走完,这是让slow和fast同时走,fast走完后slow就是答案</span></span><br></pre></td></tr></table></figure>

<p><code>code</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">getKthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* fast=head,*slow=head;</span><br><span class="line">        <span class="comment">// 让fast先走k步</span></span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            fast=fast-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(k==<span class="number">0</span>) slow=slow-&gt;next;</span><br><span class="line">            <span class="keyword">else</span> k--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k&gt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="回文链表"><a href="#回文链表" class="headerlink" title="回文链表"></a>回文链表</h3><p><code>link:https://leetcode.cn/problems/palindrome-linked-list/</code></p>
<img src="/post/dd65d9fe/image-20221013204940579.png" alt="image-20221013204940579" style="zoom:50%;">



<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 题解</span></span><br><span class="line"><span class="section"># 找到中点,将后半部分反转,然后跟前半部分比较</span></span><br></pre></td></tr></table></figure>

<p><code>code</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;next==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        ListNode* half=<span class="built_in">findHalf</span>(head);</span><br><span class="line">        ListNode* second=half-&gt;next;</span><br><span class="line">        second=<span class="built_in">reverse</span>(second);</span><br><span class="line">        ListNode* p1=head,*p2=second;</span><br><span class="line">        <span class="keyword">while</span>(p1!=<span class="literal">nullptr</span> &amp;&amp; p2!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p1-&gt;val != p2-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            p1=p1-&gt;next;</span><br><span class="line">            p2=p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 还原链表</span></span><br><span class="line">        second=<span class="built_in">reverse</span>(second);</span><br><span class="line">        half-&gt;next=second;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反转后半部分</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">        ListNode* pre=<span class="literal">nullptr</span>,*cur=head;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            ListNode* next=cur-&gt;next;</span><br><span class="line">            cur-&gt;next=pre;</span><br><span class="line">            pre=cur;</span><br><span class="line">            cur=next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到中点</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">findHalf</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">        ListNode* slow=head,*fast=head;</span><br><span class="line">        <span class="keyword">while</span>(fast-&gt;next!=<span class="literal">nullptr</span> &amp;&amp; fast-&gt;next-&gt;next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="comment">// slow走一步,fast走两步</span></span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">            fast=fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="后缀表达式-逆波兰表达式"><a href="#后缀表达式-逆波兰表达式" class="headerlink" title="后缀表达式(逆波兰表达式)"></a>后缀表达式(逆波兰表达式)</h3><p><code>link:https://leetcode.cn/problems/8Zf90G/</code></p>
<img src="/post/dd65d9fe/image-20221014235656766.png" alt="image-20221014235656766" style="zoom:50%;">



<p><code>code</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">evalRPN</span><span class="params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt;st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:tokens)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x==<span class="string">&quot;+&quot;</span> || x==<span class="string">&quot;-&quot;</span> || x==<span class="string">&quot;*&quot;</span> || x==<span class="string">&quot;/&quot;</span>)&#123;</span><br><span class="line">                <span class="type">int</span> a=st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> b=st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(x==<span class="string">&quot;+&quot;</span>) st.<span class="built_in">push</span>(b+a);</span><br><span class="line">                <span class="keyword">if</span>(x==<span class="string">&quot;-&quot;</span>) st.<span class="built_in">push</span>(b-a);</span><br><span class="line">                <span class="keyword">if</span>(x==<span class="string">&quot;*&quot;</span>) st.<span class="built_in">push</span>(b*a);</span><br><span class="line">                <span class="keyword">if</span>(x==<span class="string">&quot;/&quot;</span>) st.<span class="built_in">push</span>(b/a);</span><br><span class="line">            &#125;<span class="keyword">else</span> st.<span class="built_in">push</span>(<span class="built_in">atoi</span>(x.<span class="built_in">c_str</span>()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> st.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="表达式树"><a href="#表达式树" class="headerlink" title="表达式树"></a>表达式树</h3><p><code>link:https://www.acwing.com/problem/content/description/3768/</code></p>
<img src="/post/dd65d9fe/image-20221015102715193.png" class title="image-20221015102715193">



<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 题解: 对表达式树进行中序遍历即可</span></span><br></pre></td></tr></table></figure>

<p><code>code</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     string val；</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">expressionTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(root-&gt;left)+root-&gt;val+<span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">string <span class="title">dfs</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right) <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">        string res;</span><br><span class="line">        res+=<span class="string">&quot;(&quot;</span>;</span><br><span class="line">        res+=<span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line">        res+=root-&gt;val;</span><br><span class="line">        res+=<span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">        res+=<span class="string">&quot;)&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="中缀表达式转后缀表达式"><a href="#中缀表达式转后缀表达式" class="headerlink" title="中缀表达式转后缀表达式"></a>中缀表达式转后缀表达式</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 思路: </span></span><br><span class="line"><span class="section"># 1.遇到数字直接输出</span></span><br><span class="line"><span class="section"># 2.遇到左括号压栈</span></span><br><span class="line"><span class="section"># 3.遇到右括号栈顶到左括号全部出栈</span></span><br><span class="line"><span class="section"># 4.遇到运算符,将栈顶优先级大于该运算符的出栈,最后将该运算符压栈</span></span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ULL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line">map&lt;string,<span class="type">int</span>&gt;mp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	mp[<span class="string">&quot;+&quot;</span>]=<span class="number">1</span>;</span><br><span class="line">	mp[<span class="string">&quot;-&quot;</span>]=<span class="number">1</span>;</span><br><span class="line">	mp[<span class="string">&quot;*&quot;</span>]=<span class="number">2</span>;</span><br><span class="line">	mp[<span class="string">&quot;/&quot;</span>]=<span class="number">2</span>;</span><br><span class="line">	mp[<span class="string">&quot;(&quot;</span>]=<span class="number">0</span>;</span><br><span class="line">	vector&lt;string&gt;res;</span><br><span class="line">	string s;</span><br><span class="line">	cin &gt;&gt; s;</span><br><span class="line">	stack&lt;string&gt;st;</span><br><span class="line">	<span class="type">int</span> n=s.<span class="built_in">length</span>();</span><br><span class="line">	<span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;n)&#123;</span><br><span class="line">		<span class="keyword">if</span>(s[i]==<span class="string">&#x27;(&#x27;</span>) st.<span class="built_in">push</span>(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">			<span class="keyword">while</span>(st.<span class="built_in">top</span>()!=<span class="string">&quot;(&quot;</span>)&#123;</span><br><span class="line">				 res.<span class="built_in">push_back</span>(st.<span class="built_in">top</span>());</span><br><span class="line">				 st.<span class="built_in">pop</span>();</span><br><span class="line">			&#125;</span><br><span class="line">			st.<span class="built_in">pop</span>();</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i]&gt;=<span class="string">&#x27;0&#x27;</span> &amp;&amp; s[i]&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">			string t;</span><br><span class="line">			t+=s[i];</span><br><span class="line">			<span class="keyword">while</span>(i+<span class="number">1</span>&lt;n &amp;&amp; s[i+<span class="number">1</span>]&gt;=<span class="string">&#x27;0&#x27;</span> &amp;&amp; s[i+<span class="number">1</span>]&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">				i++;</span><br><span class="line">				t+=s[i];</span><br><span class="line">			&#125;</span><br><span class="line">			res.<span class="built_in">push_back</span>(t);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			string p;</span><br><span class="line">			p+=s[i];</span><br><span class="line">			<span class="keyword">while</span>(st.<span class="built_in">size</span>()&gt;<span class="number">0</span> &amp;&amp; mp[st.<span class="built_in">top</span>()]&gt;=mp[p])&#123;</span><br><span class="line">				res.<span class="built_in">push_back</span>(st.<span class="built_in">top</span>());</span><br><span class="line">				st.<span class="built_in">pop</span>();</span><br><span class="line">			&#125;</span><br><span class="line">			st.<span class="built_in">push</span>(p);</span><br><span class="line">		&#125;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(st.<span class="built_in">size</span>())&#123;</span><br><span class="line">		res.<span class="built_in">push_back</span>(st.<span class="built_in">top</span>());</span><br><span class="line">		st.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:res) cout &lt;&lt; x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// cin &gt;&gt; t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="dp-2"><a href="#dp-2" class="headerlink" title="dp"></a>dp</h2><h3 id="剪绳子II"><a href="#剪绳子II" class="headerlink" title="剪绳子II"></a>剪绳子II</h3><p><code>link:https://leetcode.cn/problems/jian-sheng-zi-ii-lcof/</code></p>
<img src="/post/dd65d9fe/image-20221015190040315.png" alt="image-20221015190040315" style="zoom:50%;">



<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 题解: dp,因为取模后不能比较大小,所以要用到java的大数</span></span><br></pre></td></tr></table></figure>

<p><code>code</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        Integer mod=<span class="number">1000000007</span>;</span><br><span class="line">        BigInteger dp[]=<span class="keyword">new</span> BigInteger [<span class="number">1010</span>];</span><br><span class="line">        Arrays.<span class="built_in">fill</span>(dp, BigInteger.<span class="built_in">valueOf</span>(<span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">1</span>]=BigInteger.<span class="built_in">valueOf</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;=i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&lt;n) dp[i]=dp[i].<span class="built_in">max</span>(dp[i]).<span class="built_in">max</span>(BigInteger.<span class="built_in">valueOf</span>(i));</span><br><span class="line">                dp[i]=dp[i].<span class="built_in">max</span>(dp[i]).<span class="built_in">max</span>(dp[j<span class="number">-1</span>].<span class="built_in">multiply</span>(BigInteger.<span class="built_in">valueOf</span>(i-j+<span class="number">1</span>)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n].<span class="built_in">mod</span>(BigInteger.<span class="built_in">valueOf</span>(mod)).<span class="built_in">intValue</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="四-ac的题"><a href="#四-ac的题" class="headerlink" title="四.ac的题"></a>四.ac的题</h1><h2 id="dp-3"><a href="#dp-3" class="headerlink" title="dp"></a>dp</h2><h3 id="不同的子序列II"><a href="#不同的子序列II" class="headerlink" title="不同的子序列II"></a>不同的子序列II</h3><img src="/post/dd65d9fe/image-20221014130348601.png" alt="image-20221014130348601" style="zoom:50%;">



<p><code>link:https://leetcode.cn/problems/distinct-subsequences-ii/</code></p>
<p><code>code</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">    LL dp[<span class="number">2010</span>][<span class="number">26</span>]; <span class="comment">// dp[i][j]表示前i个以第j个字母结尾的子序列数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">distinctSubseqII</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        LL res=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n=s.<span class="built_in">size</span>();</span><br><span class="line">        s=<span class="string">&#x27;*&#x27;</span>+s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> u=s[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            dp[i][u]++;</span><br><span class="line">            <span class="comment">// 如果存在多个字母相同，只用看最后一个</span></span><br><span class="line">            <span class="comment">// 如果dp[i][u]从dp[i-1][u]转移过来,则dp[i][u]=dp[i-1][u]+1;</span></span><br><span class="line">            <span class="comment">// 证明: 若u=&#x27;e&#x27;,字符串为dcaee,字符串从dcae转移过来多了一个dcaee,多了一个ee,其他都跟dp[i-1]			// [u]等价,少了一个e,总的多一个</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">26</span>;j++) dp[i][u]+=dp[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">26</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j==u) <span class="keyword">continue</span>;</span><br><span class="line">                dp[i][j]=dp[i<span class="number">-1</span>][j];</span><br><span class="line">                dp[i][j]%=mod;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][u]%=mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            res+=dp[n][i];</span><br><span class="line">            res%=mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="公平分发饼干"><a href="#公平分发饼干" class="headerlink" title="公平分发饼干"></a>公平分发饼干</h3><p><code>link:https://leetcode.cn/problems/fair-distribution-of-cookies/</code></p>
<img src="/post/dd65d9fe/image-20221021185025723.png" alt="image-20221021185025723" style="zoom:50%;">



<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">#　题解：</span></span><br><span class="line"><span class="section"># 1.爆搜</span></span><br><span class="line"><span class="section"># 2.状压dp</span></span><br></pre></td></tr></table></figure>

<p><code>爆搜</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> bucket[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">distributeCookies</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=a.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">dfs</span>(a,<span class="number">0</span>,k);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a,<span class="type">int</span> pos,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos==a.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++) ans=<span class="built_in">max</span>(ans,bucket[i]);</span><br><span class="line">            res=<span class="built_in">min</span>(res,ans);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">            bucket[i]+=a[pos];</span><br><span class="line">            <span class="built_in">dfs</span>(a,pos+<span class="number">1</span>,k);</span><br><span class="line">            bucket[i]-=a[pos];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>dp</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// dp[i][j]表示消耗了i+1个子序列,这些子序列组成了集合j</span></span><br><span class="line">    <span class="comment">// 这i+1个子序列的元素和的最大值的最小值为dp[i][j]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// dp[i][j] = 枚举j的子集s</span></span><br><span class="line">    <span class="comment">// 取min max(dp[i-1][j^s],sum[s]) for s in j</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">distributeCookies</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=a.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">dp</span>(k+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">1</span>&lt;&lt;n,<span class="number">1e9</span>));</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">sum</span>(<span class="number">1</span>&lt;&lt;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;n);i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&gt;&gt;j&amp;<span class="number">1</span>) sum[i]+=a[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;(<span class="number">1</span>&lt;&lt;n);j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> s=j;s;s=(s<span class="number">-1</span>)&amp;j)&#123; <span class="comment">// 枚举出j的所有子集,即第i+1个人获得哪些饼干</span></span><br><span class="line">                    dp[i+<span class="number">1</span>][j]=<span class="built_in">min</span>(dp[i+<span class="number">1</span>][j],<span class="built_in">max</span>(dp[i][j^s],sum[s]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[k][(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="三数之和的多种可能"><a href="#三数之和的多种可能" class="headerlink" title="三数之和的多种可能"></a>三数之和的多种可能</h3><p><code>link:[923. 三数之和的多种可能 - 力扣（LeetCode）](https://leetcode.cn/problems/3sum-with-multiplicity/)</code></p>
<img src="/post/dd65d9fe/image-20221106145254508.png" alt="image-20221106145254508" style="zoom:50%;">



<p><code>法1(AC):将二元组存起来,然后二分</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line">LL mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;PII&gt;a[<span class="number">1010</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">threeSumMulti</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;n;j++) a[arr[i]+arr[j]].<span class="built_in">push_back</span>(&#123;i,j&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        LL res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]&gt;target) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> sum=target-arr[i];</span><br><span class="line">            <span class="keyword">if</span>(!a[sum].<span class="built_in">size</span>()) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> l=<span class="number">0</span>,r=a[sum].<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">                <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(a[sum][mid].first&gt;i) r=mid;</span><br><span class="line">                <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(a[sum][l].first&gt;i) res+=a[sum].<span class="built_in">size</span>()-l;</span><br><span class="line">            res%=mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><code>法2:dp</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line">LL mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// dp[i][j][k]表示从前i个数中选出j个组成k的方案数</span></span><br><span class="line">    LL dp[<span class="number">3007</span>][<span class="number">4</span>][<span class="number">307</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">threeSumMulti</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=a.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) dp[i][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">3</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=target;k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(k&gt;=a[i<span class="number">-1</span>]) dp[i][j][k]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>][k-a[i<span class="number">-1</span>]];</span><br><span class="line">                    dp[i][j][k]+=dp[i<span class="number">-1</span>][j][k];</span><br><span class="line">                    dp[i][j][k]%=mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][<span class="number">3</span>][target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h2 id="数据结构-2"><a href="#数据结构-2" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="和至少为K的最短子数组"><a href="#和至少为K的最短子数组" class="headerlink" title="和至少为K的最短子数组"></a>和至少为K的最短子数组</h3><p><code>link:https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/</code></p>
<img src="/post/dd65d9fe/image-20221026185610420.png" alt="image-20221026185610420" style="zoom:50%;">



<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 题解:</span></span><br><span class="line"><span class="section"># 1.二分+单调队列(AC)</span></span><br><span class="line"><span class="section"># 2.单调队列</span></span><br></pre></td></tr></table></figure>

<p><code>二分</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LL sum[<span class="number">100010</span>];</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">shortestSubarray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        n=a.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) sum[i+<span class="number">1</span>]=sum[i]+a[i];</span><br><span class="line">        <span class="type">int</span> l=<span class="number">1</span>,r=n;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(mid,k)) r=mid;</span><br><span class="line">            <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">check</span>(l,k)?l:<span class="number">-1</span>;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> mid,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">        deque&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">        LL ans=<span class="number">-1e11</span>;</span><br><span class="line">        q.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(q.<span class="built_in">size</span>() &amp;&amp; i-q.<span class="built_in">front</span>()&gt;mid) q.<span class="built_in">pop_front</span>();</span><br><span class="line">            <span class="keyword">while</span>(q.<span class="built_in">size</span>() &amp;&amp; sum[q.<span class="built_in">back</span>()]&gt;=sum[i]) q.<span class="built_in">pop_back</span>();</span><br><span class="line">            q.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">if</span>(q.<span class="built_in">size</span>()) ans=<span class="built_in">max</span>(ans,sum[i]-sum[q.<span class="built_in">front</span>()]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans&gt;=k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>单调队列</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LL sum[<span class="number">100010</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">shortestSubarray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=a.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) sum[i+<span class="number">1</span>]=sum[i]+a[i]; </span><br><span class="line">        deque&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        <span class="type">int</span> res=n+<span class="number">1</span>;</span><br><span class="line">        q.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(q.<span class="built_in">size</span>() &amp;&amp; sum[i]-sum[q.<span class="built_in">front</span>()]&gt;=k)&#123;</span><br><span class="line">                res=<span class="built_in">min</span>(res,i-q.<span class="built_in">front</span>());</span><br><span class="line">                q.<span class="built_in">pop_front</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(q.<span class="built_in">size</span>() &amp;&amp; sum[i]&lt;sum[q.<span class="built_in">back</span>()]) q.<span class="built_in">pop_back</span>();</span><br><span class="line">            q.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res==n+<span class="number">1</span>?<span class="number">-1</span>:res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>单调队列2</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LL sum[<span class="number">100010</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">shortestSubarray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=a.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) sum[i+<span class="number">1</span>]=sum[i]+a[i]; </span><br><span class="line">        deque&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        <span class="type">int</span> res=n+<span class="number">1</span>;</span><br><span class="line">        q.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(q.<span class="built_in">size</span>() &amp;&amp; i-q.<span class="built_in">front</span>()&gt;res) q.<span class="built_in">pop_front</span>(); <span class="comment">// 不断缩小窗口</span></span><br><span class="line">            <span class="keyword">while</span>(q.<span class="built_in">size</span>() &amp;&amp; sum[i]-sum[q.<span class="built_in">front</span>()]&gt;=k)&#123;</span><br><span class="line">                res=<span class="built_in">min</span>(res,i-q.<span class="built_in">front</span>());</span><br><span class="line">                q.<span class="built_in">pop_front</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(q.<span class="built_in">size</span>() &amp;&amp; sum[i]&lt;sum[q.<span class="built_in">back</span>()]) q.<span class="built_in">pop_back</span>();</span><br><span class="line">            q.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res==n+<span class="number">1</span>?<span class="number">-1</span>:res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="最大宽坡度"><a href="#最大宽坡度" class="headerlink" title="最大宽坡度"></a>最大宽坡度</h3><p><code>link:https://leetcode.cn/problems/maximum-width-ramp/description/</code></p>
<img src="/post/dd65d9fe/image-20221105204646142.png" alt="image-20221105204646142" style="zoom:50%;">

<p><code>法1:二分+set(AC)</code></p>
<blockquote>
<p>法2: 单调栈</p>
<ol>
<li>维护一个单调递减的栈，保存所有可能的答案</li>
</ol>
<ul>
<li>为什么要维护一个单调递减的栈？</li>
<li>因为左边的值越小越好，若右边的值比左边大，显然左边的答案更优</li>
</ul>
<ol start="2">
<li>从后往前遍历，若当前元素比栈顶元素大，则不断弹出栈顶，更新答案，若当前元素比栈顶元素小，则看下一位遍历的元素</li>
</ol>
<ul>
<li>为什么要不断弹出栈顶元素？</li>
<li>因为当前元素在越右边越好…</li>
</ul>
</blockquote>
<p><code>二分</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxWidthRamp</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        vector&lt;PII&gt;a;</span><br><span class="line">        set&lt;<span class="type">int</span>&gt;s;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) a.<span class="built_in">push_back</span>(&#123;nums[i],i&#125;);</span><br><span class="line">        <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>(),[](<span class="keyword">auto</span> &amp;x,<span class="keyword">auto</span> &amp;y)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x.first==y.first) <span class="keyword">return</span> x.second&gt;y.second;</span><br><span class="line">            <span class="keyword">return</span> x.first&gt;y.first;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!s.<span class="built_in">size</span>()) s.<span class="built_in">insert</span>(a[i].second);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">int</span> cur=a[i].second;</span><br><span class="line">                res=<span class="built_in">max</span>(res,*s.<span class="built_in">rbegin</span>()-cur);</span><br><span class="line">                s.<span class="built_in">insert</span>(cur);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><code>单调栈</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxWidthRamp</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt;st;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!st.<span class="built_in">size</span>() || nums[st.<span class="built_in">top</span>()]&gt;nums[i]) st.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">while</span>(st.<span class="built_in">size</span>() &amp;&amp; nums[i]&gt;=nums[st.<span class="built_in">top</span>()])&#123;</span><br><span class="line">                <span class="type">int</span> cur=st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                res=<span class="built_in">max</span>(res,i-cur);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">LIM</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/post/dd65d9fe.html">http://example.com/post/dd65d9fe.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">LIMの博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/leetcode/">leetcode</a><a class="post-meta__tags" href="/tags/acm/">acm</a><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/">算法竞赛</a></div><div class="post_share"><div class="social-share" data-image="/img/wallhaven-l35pw2.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/f255ffad.html" title="docker"><img class="cover" src="/img/wallhaven-3z32j3.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">docker</div></div></a></div><div class="next-post pull-right"><a href="/post/42a782a4.html" title="vue+element-ui"><img class="cover" src="/img/wallhaven-o5dj1p.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">vue+element-ui</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/post/aabf0cad.html" title="算法竞赛模板"><img class="cover" src="/img/wallhaven-jx91d5.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-17</div><div class="title">算法竞赛模板</div></div></a></div><div><a href="/post/1c53329c.html" title="剑指offer"><img class="cover" src="/img/wallhaven-j3l8vp.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-19</div><div class="title">剑指offer</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/3534643.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">LIM</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Scorpios7"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Scorpios7" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到LIM的知识海洋</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%94%99%E9%A2%98"><span class="toc-number">1.</span> <span class="toc-text">错题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E5%9B%BE"><span class="toc-number">1.1.</span> <span class="toc-text">树图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E4%B8%AD%E7%9A%84%E6%9C%80%E9%95%BF%E7%8E%AF"><span class="toc-number">1.1.1.</span> <span class="toc-text">图中的最长环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E9%99%A4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%90%8C%E8%A1%8C%E6%88%96%E5%90%8C%E5%88%97%E7%9F%B3%E5%A4%B4"><span class="toc-number">1.1.2.</span> <span class="toc-text">移除最多的同行或同列石头</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">1.1.3.</span> <span class="toc-text">修剪二叉搜索树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E6%A0%91"><span class="toc-number">1.1.4.</span> <span class="toc-text">寻找重复的子树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83"><span class="toc-number">1.2.</span> <span class="toc-text">贪心</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8A%BF%E6%B4%97%E7%89%8C"><span class="toc-number">1.2.1.</span> <span class="toc-text">优势洗牌</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dp"><span class="toc-number">1.3.</span> <span class="toc-text">dp</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DIII"><span class="toc-number">1.3.1.</span> <span class="toc-text">打家劫舍III</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E6%95%B0%E7%BB%84%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E6%9C%89%E6%95%88%E5%88%92%E5%88%86"><span class="toc-number">1.3.2.</span> <span class="toc-text">检查数组是否存在有效划分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%B0%E5%AE%B6%E7%9A%84%E6%9C%80%E5%B0%91%E8%B7%B3%E8%B7%83%E6%AC%A1%E6%95%B0"><span class="toc-number">1.3.3.</span> <span class="toc-text">到家的最少跳跃次数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%99%BA%E5%8A%9B%E9%97%AE%E9%A2%98"><span class="toc-number">1.3.4.</span> <span class="toc-text">解决智力问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">1.3.5.</span> <span class="toc-text">不同的二叉搜索树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A0%E9%99%A4%E6%95%B0"><span class="toc-number">1.3.6.</span> <span class="toc-text">对字符串可执行的最大删除数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E4%B8%8A%E6%9C%80%E5%A4%A7%E5%BE%97%E5%88%86%E5%92%8C%E8%B7%AF%E5%BE%84"><span class="toc-number">1.3.7.</span> <span class="toc-text">树上最大得分和路径</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.</span> <span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-number">1.4.1.</span> <span class="toc-text">删除链表中的节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%AF%E5%BD%A2%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C"><span class="toc-number">1.4.2.</span> <span class="toc-text">环形子数组的最大和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%89%8D%E7%BC%80%E5%88%86%E6%95%B0%E5%92%8C"><span class="toc-number">1.4.3.</span> <span class="toc-text">字符串的前缀分数和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%AC%E5%8F%B7%E7%9A%84%E5%88%86%E6%95%B0"><span class="toc-number">1.4.4.</span> <span class="toc-text">括号的分数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%88%86"><span class="toc-number">1.5.</span> <span class="toc-text">二分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A2%8B%E5%AD%90%E9%87%8C%E6%9C%80%E5%B0%91%E6%95%B0%E7%9B%AE%E7%9A%84%E7%90%83"><span class="toc-number">1.5.1.</span> <span class="toc-text">袋子里最少数目的球</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E4%BD%8D%E6%88%96%E6%9C%80%E5%A4%A7%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%90%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6"><span class="toc-number">1.5.2.</span> <span class="toc-text">按位或最大的最小子数组长度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#STL"><span class="toc-number">1.6.</span> <span class="toc-text">STL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%A7%BB%E9%99%A4%E6%98%9F%E5%8F%B7"><span class="toc-number">1.6.1.</span> <span class="toc-text">从字符串中移除星号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#int%E5%92%8Cstring%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.6.2.</span> <span class="toc-text">int和string的相互转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vector"><span class="toc-number">1.6.3.</span> <span class="toc-text">vector</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#set"><span class="toc-number">1.6.4.</span> <span class="toc-text">set</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#string"><span class="toc-number">1.6.5.</span> <span class="toc-text">string</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-number">1.7.</span> <span class="toc-text">双指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E5%AE%9A%E7%95%8C%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%95%B0%E7%9B%AE"><span class="toc-number">1.7.1.</span> <span class="toc-text">统计定界子数组的数目</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C-%E4%B8%8D%E4%BC%9A%E7%9A%84%E9%A2%98"><span class="toc-number">2.</span> <span class="toc-text">二. 不会的题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88-1"><span class="toc-number">2.1.</span> <span class="toc-text">双指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="toc-number">2.1.1.</span> <span class="toc-text">盛最多水的容器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dp-1"><span class="toc-number">2.2.</span> <span class="toc-text">dp</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%92%E8%9B%99%E8%BF%87%E6%B2%B3"><span class="toc-number">2.2.1.</span> <span class="toc-text">青蛙过河</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%B3%E6%B0%94%E7%90%83"><span class="toc-number">2.2.2.</span> <span class="toc-text">戳气球</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E9%94%99%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">2.2.3.</span> <span class="toc-text">交错字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%A5%E9%81%93%E7%A7%98%E5%AF%86%E7%9A%84%E4%BA%BA%E6%95%B0"><span class="toc-number">2.2.4.</span> <span class="toc-text">知道秘密的人数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%91%E6%95%B0II"><span class="toc-number">2.2.5.</span> <span class="toc-text">丑数II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97II"><span class="toc-number">2.2.6.</span> <span class="toc-text">最长递增子序列II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E7%89%B9%E6%AE%8A%E6%95%B4%E6%95%B0-%E6%95%B0%E4%BD%8Ddp%E6%A8%A1%E6%9D%BF"><span class="toc-number">2.2.7.</span> <span class="toc-text">统计特殊整数(数位dp模板)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%80%BB%E5%BC%95%E5%8A%9B"><span class="toc-number">2.2.8.</span> <span class="toc-text">字符串的总引力</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%84%E5%88%92%E5%85%BC%E8%81%8C%E5%B7%A5%E4%BD%9C"><span class="toc-number">2.2.9.</span> <span class="toc-text">规划兼职工作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%84%E7%BD%97%E6%96%AF%E5%A5%97%E5%A8%83%E4%BF%A1%E5%B0%81%E9%97%AE%E9%A2%98"><span class="toc-number">2.2.10.</span> <span class="toc-text">俄罗斯套娃信封问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E6%8E%92%E9%82%AE%E7%AD%92"><span class="toc-number">2.2.11.</span> <span class="toc-text">安排邮筒</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%A7%BB%E5%8A%A8%E6%80%BB%E8%B7%9D%E7%A6%BB"><span class="toc-number">2.2.12.</span> <span class="toc-text">最小移动总距离</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%B1%B3%E8%AF%BA%E5%92%8C%E6%89%98%E7%B1%B3%E8%AF%BA%E5%B9%B3%E9%93%BA"><span class="toc-number">2.2.13.</span> <span class="toc-text">多米诺和托米诺平铺</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#N%E6%AC%A1%E6%93%8D%E4%BD%9C%E5%90%8E%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%86%E6%95%B0%E5%92%8C"><span class="toc-number">2.2.14.</span> <span class="toc-text">N次操作后的最大分数和</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83-1"><span class="toc-number">2.3.</span> <span class="toc-text">贪心</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4"><span class="toc-number">2.3.1.</span> <span class="toc-text">无重叠区间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E6%B2%B9%E7%AB%99"><span class="toc-number">2.3.2.</span> <span class="toc-text">加油站</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E6%95%B0%E7%BB%84%E7%9B%B8%E7%AD%89%E7%9A%84%E6%9C%80%E5%B0%8F%E5%BC%80%E9%94%80"><span class="toc-number">2.3.3.</span> <span class="toc-text">使数组相等的最小开销</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E8%A1%8C%E8%BD%A6%E6%8B%89%E5%8A%9B%E8%B5%9B"><span class="toc-number">2.3.4.</span> <span class="toc-text">自行车拉力赛</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2"><span class="toc-number">2.4.</span> <span class="toc-text">搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%92%E5%88%86%E4%B8%BAk%E4%B8%AA%E7%9B%B8%E7%AD%89%E7%9A%84%E5%AD%90%E9%9B%86"><span class="toc-number">2.4.1.</span> <span class="toc-text">划分为k个相等的子集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%ACK%E4%B8%AA%E8%AF%AD%E6%B3%95%E7%AC%A6%E5%8F%B7"><span class="toc-number">2.4.2.</span> <span class="toc-text">第K个语法符号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%89%80%E6%9C%89%E9%92%A5%E5%8C%99%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="toc-number">2.4.3.</span> <span class="toc-text">获取所有钥匙的最短路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%9D%87%E5%80%BC%E5%88%86%E5%89%B2"><span class="toc-number">2.4.4.</span> <span class="toc-text">数组的均值分割</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E5%9B%BE-1"><span class="toc-number">2.5.</span> <span class="toc-text">树图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%83%BD%E7%9A%84%E4%BA%8C%E5%88%86%E6%B3%95"><span class="toc-number">2.5.1.</span> <span class="toc-text">可能的二分法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%BB%B7%E5%80%BC%E7%9B%B8%E5%90%8C%E7%9A%84%E8%BF%9E%E9%80%9A%E5%9D%97"><span class="toc-number">2.5.2.</span> <span class="toc-text">创建价值相同的连通块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LCA"><span class="toc-number">2.5.3.</span> <span class="toc-text">LCA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9%E5%88%B0%E5%8F%A6%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9%E6%AF%8F%E4%B8%80%E6%AD%A5%E7%9A%84%E6%96%B9%E5%90%91"><span class="toc-number">2.5.4.</span> <span class="toc-text">从二叉树一个节点到另一个节点每一步的方向</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E9%99%A4%E5%AD%90%E6%A0%91%E5%90%8E%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%E9%AB%98%E5%BA%A6"><span class="toc-number">2.5.5.</span> <span class="toc-text">移除子树后的二叉树高度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%90%E5%B1%82%E6%8E%92%E5%BA%8F%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%80%E9%9C%80%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%95%B0%E7%9B%AE"><span class="toc-number">2.5.6.</span> <span class="toc-text">逐层排序二叉树所需的最少操作数目</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1"><span class="toc-number">2.6.</span> <span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E7%90%86%E4%B9%A6%E6%9E%B6"><span class="toc-number">2.6.1.</span> <span class="toc-text">整理书架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%9D%E5%AF%B9%E5%B7%AE%E4%B8%8D%E8%B6%85%E8%BF%87%E9%99%90%E5%88%B6%E7%9A%84%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">2.6.2.</span> <span class="toc-text">绝对差不超过限制的最长连续子数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC%E4%B9%8B%E5%92%8C"><span class="toc-number">2.6.3.</span> <span class="toc-text">子数组的最小值之和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0IV"><span class="toc-number">2.6.4.</span> <span class="toc-text">下一个更大元素IV</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E7%BA%BF%E7%A8%8BCPU"><span class="toc-number">2.6.5.</span> <span class="toc-text">单线程CPU</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E7%BB%B4"><span class="toc-number">2.7.</span> <span class="toc-text">思维</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%91%E7%99%BD%E6%A3%8B%E6%B8%B8%E6%88%8F"><span class="toc-number">2.7.1.</span> <span class="toc-text">黑白棋游戏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E5%BA%8F%E5%88%97%E5%AE%BD%E5%BA%A6%E4%B9%8B%E5%92%8C"><span class="toc-number">2.7.2.</span> <span class="toc-text">子序列宽度之和</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%AD%A6"><span class="toc-number">2.8.</span> <span class="toc-text">数学</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#878-%E7%AC%AC-N-%E4%B8%AA%E7%A5%9E%E5%A5%87%E6%95%B0%E5%AD%97-%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89"><span class="toc-number">2.8.1.</span> <span class="toc-text">878. 第 N 个神奇数字 - 力扣（LeetCode）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E4%BC%98%E5%8C%96"><span class="toc-number">2.9.</span> <span class="toc-text">枚举优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E4%B8%8A%E5%8D%87%E5%9B%9B%E5%85%83%E7%BB%84"><span class="toc-number">2.9.1.</span> <span class="toc-text">统计上升四元组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%9A%E5%BC%88"><span class="toc-number">2.10.</span> <span class="toc-text">博弈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8FVII"><span class="toc-number">2.10.1.</span> <span class="toc-text">石子游戏VII</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89-%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%95%E9%A2%98"><span class="toc-number">3.</span> <span class="toc-text">三. 面试笔试题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E7%BB%B4-1"><span class="toc-number">3.1.</span> <span class="toc-text">思维</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%BD%AE%E8%BD%AC%E6%95%B0%E7%BB%84"><span class="toc-number">3.1.1.</span> <span class="toc-text">1. 轮转数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-number">3.2.</span> <span class="toc-text">链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-number">3.2.1.</span> <span class="toc-text">反转链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0"><span class="toc-number">3.2.2.</span> <span class="toc-text">删除排序链表中的重复元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0II"><span class="toc-number">3.2.3.</span> <span class="toc-text">删除排序链表中的重复元素II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="toc-number">3.2.4.</span> <span class="toc-text">链表中倒数第k个节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8"><span class="toc-number">3.2.5.</span> <span class="toc-text">回文链表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88"><span class="toc-number">3.3.</span> <span class="toc-text">栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">3.3.1.</span> <span class="toc-text">后缀表达式(逆波兰表达式)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91"><span class="toc-number">3.3.2.</span> <span class="toc-text">表达式树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">3.3.3.</span> <span class="toc-text">中缀表达式转后缀表达式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dp-2"><span class="toc-number">3.4.</span> <span class="toc-text">dp</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%AA%E7%BB%B3%E5%AD%90II"><span class="toc-number">3.4.1.</span> <span class="toc-text">剪绳子II</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B-ac%E7%9A%84%E9%A2%98"><span class="toc-number">4.</span> <span class="toc-text">四.ac的题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#dp-3"><span class="toc-number">4.1.</span> <span class="toc-text">dp</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97II"><span class="toc-number">4.1.1.</span> <span class="toc-text">不同的子序列II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AC%E5%B9%B3%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2"><span class="toc-number">4.1.2.</span> <span class="toc-text">公平分发饼干</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%E7%9A%84%E5%A4%9A%E7%A7%8D%E5%8F%AF%E8%83%BD"><span class="toc-number">4.1.3.</span> <span class="toc-text">三数之和的多种可能</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2"><span class="toc-number">4.2.</span> <span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%92%8C%E8%87%B3%E5%B0%91%E4%B8%BAK%E7%9A%84%E6%9C%80%E7%9F%AD%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">4.2.1.</span> <span class="toc-text">和至少为K的最短子数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%AE%BD%E5%9D%A1%E5%BA%A6"><span class="toc-number">4.2.2.</span> <span class="toc-text">最大宽坡度</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/f63ae8ae.html" title="考研英语核心2000词"><img src="/img/wallhaven-vqzjz5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="考研英语核心2000词"/></a><div class="content"><a class="title" href="/post/f63ae8ae.html" title="考研英语核心2000词">考研英语核心2000词</a><time datetime="2023-04-08T14:38:53.000Z" title="发表于 2023-04-08 22:38:53">2023-04-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/5a73032.html" title="Redis生产问题"><img src="/img/wallhaven-dp2gpg.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis生产问题"/></a><div class="content"><a class="title" href="/post/5a73032.html" title="Redis生产问题">Redis生产问题</a><time datetime="2023-02-28T03:35:08.000Z" title="发表于 2023-02-28 11:35:08">2023-02-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/f4df40a6.html" title="JVM内存区域"><img src="/img/1303988.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JVM内存区域"/></a><div class="content"><a class="title" href="/post/f4df40a6.html" title="JVM内存区域">JVM内存区域</a><time datetime="2023-02-28T02:51:37.000Z" title="发表于 2023-02-28 10:51:37">2023-02-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/32178238.html" title="认识JVM"><img src="/img/wallhaven-vg69p3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="认识JVM"/></a><div class="content"><a class="title" href="/post/32178238.html" title="认识JVM">认识JVM</a><time datetime="2023-02-28T01:54:40.000Z" title="发表于 2023-02-28 09:54:40">2023-02-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/4e62fa9c.html" title="Redis可持久化机制"><img src="/img/wallhaven-zxyy5w.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis可持久化机制"/></a><div class="content"><a class="title" href="/post/4e62fa9c.html" title="Redis可持久化机制">Redis可持久化机制</a><time datetime="2023-02-26T12:57:19.000Z" title="发表于 2023-02-26 20:57:19">2023-02-26</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 By LIM</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>