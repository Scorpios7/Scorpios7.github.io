<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>docker | LIMの博客</title><meta name="author" content="LIM"><meta name="copyright" content="LIM"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. Docker概述1.1 Dokcer简介Docker是基于Go语言实现的云开源项目。 Docker的主要目标是：Build, Ship and Run Any App, Anywhere，也就是通过对应用组件的封装、分发、部署、运行等生命周期的管理，使用户的APP及其运行环境能做到一次镜像,处处运行。 1.2 传统虚拟机与容器 传统虚拟机（virtual machine）： 传统虚拟机技术基">
<meta property="og:type" content="article">
<meta property="og:title" content="docker">
<meta property="og:url" content="http://example.com/post/f255ffad.html">
<meta property="og:site_name" content="LIMの博客">
<meta property="og:description" content="1. Docker概述1.1 Dokcer简介Docker是基于Go语言实现的云开源项目。 Docker的主要目标是：Build, Ship and Run Any App, Anywhere，也就是通过对应用组件的封装、分发、部署、运行等生命周期的管理，使用户的APP及其运行环境能做到一次镜像,处处运行。 1.2 传统虚拟机与容器 传统虚拟机（virtual machine）： 传统虚拟机技术基">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/wallhaven-3z32j3.jpg">
<meta property="article:published_time" content="2023-02-18T13:26:55.000Z">
<meta property="article:modified_time" content="2023-02-20T02:53:58.597Z">
<meta property="article:author" content="LIM">
<meta property="article:tag" content="docker">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/wallhaven-3z32j3.jpg"><link rel="shortcut icon" href="/img/letter-l.png"><link rel="canonical" href="http://example.com/post/f255ffad.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'docker',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-02-20 10:53:58'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/background.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/3534643.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 时间轴</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="LIMの博客"><span class="site-name">LIMの博客</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 时间轴</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">docker</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-02-18T13:26:55.000Z" title="发表于 2023-02-18 21:26:55">2023-02-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-02-20T02:53:58.597Z" title="更新于 2023-02-20 10:53:58">2023-02-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">12.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>47分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="docker"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="1-Docker概述"><a href="#1-Docker概述" class="headerlink" title="1. Docker概述"></a>1. Docker概述</h1><h2 id="1-1-Dokcer简介"><a href="#1-1-Dokcer简介" class="headerlink" title="1.1 Dokcer简介"></a>1.1 Dokcer简介</h2><p>Docker是基于Go语言实现的云开源项目。</p>
<p>Docker的主要目标是：<code>Build, Ship and Run Any App, Anywhere</code>，也就是通过对应用组件的封装、分发、部署、运行等生命周期的管理，使用户的APP及其运行环境能做到<strong>一次镜像,处处运行</strong>。</p>
<h2 id="1-2-传统虚拟机与容器"><a href="#1-2-传统虚拟机与容器" class="headerlink" title="1.2 传统虚拟机与容器"></a>1.2 传统虚拟机与容器</h2><blockquote>
<p>传统虚拟机（virtual machine）：</p>
<p>传统虚拟机技术基于安装在主操作系统上的虚拟机管理系统（如VirtualBox、VMware等），创建虚拟机（虚拟出各种硬件），在虚拟机上安装从操作系统，在从操作系统中安装部署各种应用。</p>
<p>缺点：资源占用多、冗余步骤多、启动慢</p>
<p>Linux容器（Linux Container，简称LXC）：</p>
<p>Linux容器是与系统其他部分分隔开的一系列进程，从另一个镜像运行，并由该镜像提供支持进程所需的全部文件。容器提供的镜像包含了应用的所有依赖项，因而在从开发到测试再到生产的整个过程中，它都具有可移植性和一致性。</p>
<p>Linux容器不是模拟一个完整的操作系统，而是对进程进行隔离。有了容器，就可以将软件运行所需的所有资源打包到一个隔离的容器中。容器与虚拟机不同，不需要捆绑一整套操作系统，只需要软件工作所需的库资源和设置。系统因此而变得高效轻量并保证部署在任何环境中的软件都能始终如一的运行</p>
</blockquote>
<img src="/post/f255ffad/1652093324480-073374a2-4ce3-4a56-932b-5a73329736a2.jpeg" class title="virtual-machine-vs-docker-container.jpg">

<p>对比:</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>容器</th>
<th>虚拟机</th>
</tr>
</thead>
<tbody><tr>
<td>启动</td>
<td>秒级</td>
<td>分钟级</td>
</tr>
<tr>
<td>大小</td>
<td>一般为Mb</td>
<td>一般为Gb</td>
</tr>
<tr>
<td>速度</td>
<td>接近原生</td>
<td>比较慢</td>
</tr>
<tr>
<td>系统支持数量</td>
<td>单机支持上千个容器</td>
<td>一般几十个</td>
</tr>
</tbody></table>
<h2 id="1-3-Docker运行速度快的原因"><a href="#1-3-Docker运行速度快的原因" class="headerlink" title="1.3 Docker运行速度快的原因"></a>1.3 Docker运行速度快的原因</h2><blockquote>
<p>Docker有比虚拟机更少的抽象层：</p>
<p>由于Docker不需要Hypervisor（虚拟机）实现硬件资源虚拟化，运行在Docker容器上的程序直接使用的都是实际物理机的硬件资源，因此在CPU、内存利用率上docker有明显优势。</p>
<p>Docker利用的是宿主机的内核，而不需要加载操作系统OS内核：</p>
<p>当新建一个容器时，Docker不需要和虚拟机一样重新加载一个操作系统内核。进而避免引寻、加载操作系统内核返回等比较耗时耗资源的过程。当新建一个虚拟机时，虚拟机软件需要加载OS，返回新建过程是分钟级别的。而Docker由于直接利用宿主机的操作系统，则省略了返回过程，因此新建一个docker容器只需要几秒钟。</p>
<p>Docker容器的本质就是一个进程。</p>
</blockquote>
<h2 id="1-4-Docker软件"><a href="#1-4-Docker软件" class="headerlink" title="1.4 Docker软件"></a>1.4 Docker软件</h2><blockquote>
<p>Docker并非一个通用的容器工具，它依赖于已经存在并运行的Linux内核环境。（在Windows上安装Docker时需要依赖WLS，也即Windows下的Linux子系统）。</p>
<p>Docker实质上是在已经运行的Linux下制造了一个隔离的文件环境，因此它执行的效率几乎等同于所部署的Linux主机。</p>
<p>Docker的基本组成部分：</p>
<ul>
<li>镜像（image）</li>
<li>容器（container）</li>
<li>仓库（repository）</li>
</ul>
</blockquote>
<h2 id="1-5-Docker镜像"><a href="#1-5-Docker镜像" class="headerlink" title="1.5 Docker镜像"></a>1.5 Docker镜像</h2><blockquote>
<p>Docker利用容器独立运行的一个或一组应用，应用程序或服务运行在容器里面，容器就类似于一个虚拟化的运行环境，容器是用镜像创建的运行实例。</p>
</blockquote>
<h2 id="1-6-Docker仓库"><a href="#1-6-Docker仓库" class="headerlink" title="1.6 Docker仓库"></a>1.6 Docker仓库</h2><blockquote>
<p>Docker仓库是集中存放镜像文件的场所。</p>
<p>仓库分为公开仓库和私有仓库两种。</p>
<p>最大的公开仓库是Docker官方的Docker Hub：<a target="_blank" rel="noopener" href="https://hub.docker.com/">https://hub.docker.com/</a></p>
</blockquote>
<h2 id="1-7-Docker架构"><a href="#1-7-Docker架构" class="headerlink" title="1.7 Docker架构"></a>1.7 Docker架构</h2><blockquote>
<p>Docker是一个 C&#x2F;S（Client-Server） 结构的系统，后端是一个松耦合架构，众多模块各司其职。</p>
<p>Docker守护进程运行在主机上，然后通过Socket连接从客户端访问，守护进程从容器接收命令并管理运行在主机上的容器。</p>
</blockquote>
<img src="/post/f255ffad/1652093339897-20255a0a-e981-43e3-9e9e-654b8da3b2c8.svg" class title="architecture.svg">

<blockquote>
<p>Docker运行的基本流程为：</p>
<ol>
<li><p>用户是使用Docker Client 与 Docker Daemon 建立通信，并发送请求给后者</p>
</li>
<li><p>Docker Daemon 作为 Docker 架构的主体部分，首先提供 Docker Server 的功能使其可以接收 Docker Client 的请求</p>
</li>
<li><p>Docker Engine 执行 Docker 内部的一系列工作，每一项工作都是以一个 Job 的形式存在</p>
</li>
<li><p>Job 的运行过程中，当需要容器镜像时，则从 Docker Registry 中下载镜像，并通过镜像管理驱动 Graph Driver 将下载镜像以 Graph 的形式存储</p>
</li>
<li><p>当需要为 Docker 创建网络环境时，通过网络管理驱动 Network driver 创建并配置 Docker 容器网络环境</p>
</li>
<li><p>当需要限制 Docker 容器运行资源或执行用户指令等操作时，则通过 Exec driver 来完成</p>
</li>
<li><p>Libcontainer 是一项独立的容器管理包，Network driver 以及 Exec driver 都是通过 Libcontainer 来实现具体对容器进行的操作</p>
</li>
</ol>
</blockquote>
<img src="/post/f255ffad/1652093347909-4fcf65d1-da12-47cb-9a2f-0c4528d7e4c9.png" class title="flow.png">





<h1 id="2-Docker安装"><a href="#2-Docker安装" class="headerlink" title="2. Docker安装"></a>2. Docker安装</h1><h2 id="2-1-Centos安装Docker"><a href="#2-1-Centos安装Docker" class="headerlink" title="2.1 Centos安装Docker"></a>2.1 Centos安装Docker</h2><p><code>参考官网：https://docs.docker.com/engine/install/centos/</code></p>
<h2 id="2-2-卸载旧版本"><a href="#2-2-卸载旧版本" class="headerlink" title="2.2 卸载旧版本"></a>2.2 卸载旧版本</h2><p>如果之前安装过Docker，需要先卸载旧版本：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure>

<blockquote>
<p>旧版本的Docker引擎包可能叫做：<code>docker</code>、<code>docker-engine</code>。</p>
<p>新版本的Docker引擎包叫做：<code>docker-ce</code></p>
</blockquote>
<h2 id="2-3-配置yum资源库"><a href="#2-3-配置yum资源库" class="headerlink" title="2.3 配置yum资源库"></a>2.3 配置yum资源库</h2><p>安装<code>yum-config-manager</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">yum-util提供yum-config-manager功能</span> </span><br><span class="line">sudo yum install -y yum-utils</span><br></pre></td></tr></table></figure>

<p>配置docker的资源库地址：</p>
<p>官方地址：（比较慢，不推荐）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在yum资源库中添加docker资源库</span></span><br><span class="line">sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>

<p>阿里云镜像地址：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>

<blockquote>
<p>阿里云官网提供了很多资源镜像，镜像地址：<code>https://mirrors.aliyun.com</code>，进入之后可以选择自己需要的资源进行配置</p>
</blockquote>
<p>创建缓存（可选）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum makecache fast</span><br></pre></td></tr></table></figure>

<h2 id="2-4-安装Docker引擎"><a href="#2-4-安装Docker引擎" class="headerlink" title="2.4 安装Docker引擎"></a>2.4 安装Docker引擎</h2><p>安装最新版本的Docker引擎、Docker客户端：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker-ce是Docker引擎，docker-ce-cli是客户端</span></span><br><span class="line">sudo yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin</span><br></pre></td></tr></table></figure>

<p>此时，默认安装的docker引擎、客户端都是最新版本。</p>
<p>如果要安装指定版本：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询版本列表</span></span><br><span class="line">yum list docker-ce --showduplicates | sort -r</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定版本安装17.09.0.ce版</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sudo yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io docker-compose-plugin</span></span><br><span class="line">sudo yum install docker-ce-17.09.0.ce docker-ce-cli-17.09.0.ce containerd.io docker-compose-plugin</span><br></pre></td></tr></table></figure>

<h2 id="2-5-启动docker引擎"><a href="#2-5-启动docker引擎" class="headerlink" title="2.5 启动docker引擎"></a>2.5 启动docker引擎</h2><p>如果没有启动Docker引擎，那么执行 <code>docker version</code>查看版本号时，只能看到 <code>Client: Docker Engine</code>（Docker引擎客户端）的版本号。</p>
<p>启动Docker引擎：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新版本的Docker就是一个系统服务，可以直接使用启动系统服务方式启动</span></span><br><span class="line">systemctl start docker</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">此时查看docker版本，可以看到Server: Docker Engine（Docker引擎）版本号</span></span><br><span class="line">docker version</span><br></pre></td></tr></table></figure>

<h2 id="2-6-卸载Docker"><a href="#2-6-卸载Docker" class="headerlink" title="2.6 卸载Docker"></a>2.6 卸载Docker</h2><p>卸载Docker步骤：</p>
<ol>
<li><p>关闭服务</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop docker</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>yum</code>删除docker引擎 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum remove docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除镜像、容器、卷、自定义配置等文件 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo rm -rf /var/lib/docker</span><br><span class="line">sudo rm -rf /var/lib/containerd</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="2-7-运行HelloWorld测试"><a href="#2-7-运行HelloWorld测试" class="headerlink" title="2.7 运行HelloWorld测试"></a>2.7 运行HelloWorld测试</h2><p>运行HelloWorld：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure>





<h1 id="3-Docker下载加速"><a href="#3-Docker下载加速" class="headerlink" title="3. Docker下载加速"></a>3. Docker下载加速</h1><p><strong>方式1：使用 网易数帆、阿里云等容器镜像仓库进行下载。</strong></p>
<p>例如，下载网易数帆镜像中的mysql。（网易数帆的地址为 <code>hub.c.163.com</code>，网易数帆对dockerhub官方的镜像命名空间为 <code>library</code>）。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull hub.c.163.com/library/mysql:latest</span><br></pre></td></tr></table></figure>

<p><strong>方式2：配置阿里云加速。</strong></p>
<p>登录阿里云，进入 <code>工作台</code> -&gt; <code>容器镜像服务</code> -&gt; <code>镜像工具</code> -&gt; <code>镜像加速器</code>。</p>
<p>里面提供了一个加速器地址：<code>https://xxxxx.mirror.aliyuncs.com</code>，将该地址配置到docker中：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/docker</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">初次进来时没有/etc/docker/daemon.json文件，直接创建该文件即可</span></span><br><span class="line">vi /etc/docker/daemon.json</span><br></pre></td></tr></table></figure>

<p>在<code>daemon.json</code>中写入以下内容：（即加速器地址）</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;registry-mirrors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;https://xxxxx.mirror.aliyuncs.com&quot;</span><span class="punctuation">]</span>  </span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>然后刷新配置、重启docker即可：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">centos6 的命令</span></span><br><span class="line">sudo chkconfig daemon-reload</span><br><span class="line">sudo service docker restart</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">centos7 的命令</span></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>

<p>使用方式2可以直接下载官方的镜像，且镜像tag为官方tag，不需要加上云服务商的地址。</p>
<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysql:latest</span><br></pre></td></tr></table></figure>





<h1 id="4-Docker常用命令"><a href="#4-Docker常用命令" class="headerlink" title="4. Docker常用命令"></a>4. Docker常用命令</h1><h2 id="4-1-启动类命令"><a href="#4-1-启动类命令" class="headerlink" title="4.1 启动类命令"></a>4.1 启动类命令</h2><blockquote>
<p><strong>启动docker：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">systemctl start docker</span></span><br></pre></td></tr></table></figure>

<p><strong>停止Docker：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">systemctl stop docker</span></span><br></pre></td></tr></table></figure>

<p><strong>重启Docker：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">systemctl restart docker</span></span><br></pre></td></tr></table></figure>

<p><strong>查看状态：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">systemctl status docker</span></span><br></pre></td></tr></table></figure>

<p><strong>设置开机自启：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">systemctl <span class="built_in">enable</span> docker</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="4-2-帮助类命令"><a href="#4-2-帮助类命令" class="headerlink" title="4.2 帮助类命令"></a>4.2 帮助类命令</h2><blockquote>
<p><strong>查看Docker版本：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure>

<p><strong>查看Docker概要信息：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker info</span><br></pre></td></tr></table></figure>

<p><strong>查看Docker总体帮助文档：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker --help</span><br></pre></td></tr></table></figure>

<p><strong>查看docker具体命令帮助文档：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker 具体命令 --help</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="4-3-镜像命令"><a href="#4-3-镜像命令" class="headerlink" title="4.3 镜像命令"></a>4.3 镜像命令</h2><blockquote>
<h3 id="列出本地主机上的镜像"><a href="#列出本地主机上的镜像" class="headerlink" title="列出本地主机上的镜像"></a>列出本地主机上的镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">docker images</span></span><br></pre></td></tr></table></figure>

<p>参数:</p>
<ul>
<li><p><code>-a</code>：列出所有镜像（含历史镜像）</p>
</li>
<li><p><code>-q</code>：只显示镜像ID</p>
</li>
<li><p><code>-f</code>：过滤</p>
</li>
</ul>
<h3 id="在远程仓库中搜索镜像"><a href="#在远程仓库中搜索镜像" class="headerlink" title="在远程仓库中搜索镜像"></a>在远程仓库中搜索镜像</h3><p>（默认取docker hub中搜索）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">docker search 镜像名称</span></span><br></pre></td></tr></table></figure>

<p>参数:</p>
<ul>
<li><code>-f</code>：过滤</li>
<li><code>--limit 数量</code>：只展示前几项</li>
</ul>
<h2 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">docker pull 镜像名称[:tag]</span></span><br></pre></td></tr></table></figure>

<p>不加 tag 时，默认下载最新的镜像（即tag为<code>latest</code>）。</p>
<h2 id="查看占据的空间"><a href="#查看占据的空间" class="headerlink" title="查看占据的空间"></a>查看占据的空间</h2><p>查看镜像&#x2F;容器&#x2F;数据卷所占的空间：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">docker system <span class="built_in">df</span></span></span><br></pre></td></tr></table></figure>



<h2 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">docker rmi 镜像名称/ID</span></span><br></pre></td></tr></table></figure>

<p>可以使用空格分隔，删除多个镜像：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">docker rmi 镜像1 镜像2 镜像3</span></span><br></pre></td></tr></table></figure>

<p>删除全部镜像：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">docker rmi -f <span class="variable">$&#123;docker images -qa&#125;</span></span></span><br></pre></td></tr></table></figure>



<h2 id="虚悬镜像"><a href="#虚悬镜像" class="headerlink" title="虚悬镜像"></a>虚悬镜像</h2><p>仓库名、标签都是<code>&lt;none&gt;</code>的镜像，俗称虚悬镜像（dangling image）。</p>
<h2 id="命令自动补全"><a href="#命令自动补全" class="headerlink" title="命令自动补全"></a>命令自动补全</h2><p>docker支持命令自动补全功能，当输入镜像名前几位时，可以按<code>tab</code>键自动补全镜像名称、tag等。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash"><span class="comment"># 如果镜像中有ubuntu，查看输入ub按下tab是否可以补全</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">docker run ub</span></span><br></pre></td></tr></table></figure>

<p>如果按下<code>tab</code>时没有自动补全，可以按以下步骤操作：</p>
<ol>
<li>检查是否安装了<code>bash-completion</code>（命令补全增强包）</li>
</ol>
 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查有 /usr/share/bash-completion/bash_completion 这个文件</span></span><br><span class="line">ls /usr/share/bash-completion/bash_completion</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>如果有<code>/usr/share/bash-completion</code>目录，但是没有<code>/usr/share/bash-completion/bash_completion</code>文件（centos6为<code>/etc/bash_completion</code>文件），则需要安装<code>bash-completion</code></li>
</ol>
 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install bash-completion</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>检查是否安装了docker的自动补全</li>
</ol>
 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查/usr/share/bash-completion/completions文件夹下是否有docker开头的自动补全</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker安装完后会在该文件夹下生成自动补全文件docker</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果安装了docker-compose，则该文件夹下还会有 docker-compose文件</span></span><br><span class="line">ll /usr/share/bash-completion/completions/docker*</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>如果已经安装了docker自动补全，使用<code>source</code>命令使其生效</li>
</ol>
 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /usr/share/bash-completion/completions/docker</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>再次使用<code>tab</code>查看是否可以自动补全</li>
</ol>
 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果镜像中有ubuntu，查看输入ub按下tab是否可以补全</span></span><br><span class="line">docker run ub</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>如果有报错，且报错中提示<code>_get_comp_words_by_ref: command not found</code>。说明<code>bash-completion</code>的配置文件没有生效，需要<code>source</code>一下</li>
</ol>
 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">对于centos7，bash-completion安装的是2.x版本，配置文件为/usr/share/bash-completion/bash_completion</span></span><br><span class="line">source /usr/share/bash-completion/bash_completion</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果是centos6，自动安装的bash-completion最新版为1.x版本，配置文件为/etc/bash_completion</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">bash /etc/bash_completion</span></span><br></pre></td></tr></table></figure>

<ol start="7">
<li>再次使用<code>tab</code>查看是否可以自动补全</li>
</ol>
 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果镜像中有ubuntu，查看输入ub按下tab是否可以补全</span></span><br><span class="line">docker run ub</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="5-容器命令"><a href="#5-容器命令" class="headerlink" title="5. 容器命令"></a>5. 容器命令</h1><h2 id="5-1-新建启动容器"><a href="#5-1-新建启动容器" class="headerlink" title="5.1 新建启动容器"></a>5.1 新建启动容器</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure>

<p>常用的参数：</p>
<ul>
<li><code>--name</code>：为容器指定一个名称</li>
<li><code>-d</code>：后台运行容器并返回容器ID，也即启动守护式容器</li>
<li><code>-i</code>：以交互模式（interactive）运行容器，通常与<code>-t</code>同时使用</li>
<li><code>-t</code>：为容器重新分配一个伪输入终端（tty），通常与<code>-i</code>同时使用。也即启动交互式容器（前台有伪终端，等待交互）</li>
<li><code>-e</code>：为容器添加环境变量</li>
<li><code>-P</code>：随机端口映射。将容器内暴露的所有端口映射到宿主机随机端口</li>
<li><code>-p</code>：指定端口映射</li>
</ul>
<p><code>-p</code>指定端口映射的几种不同形式：</p>
<ul>
<li><code>-p hostPort:containerPort</code>：端口映射，例如<code>-p 8080:80</code></li>
<li><code>-p ip:hostPort:containerPort</code>：配置监听地址，例如 <code>-p 10.0.0.1:8080:80</code></li>
<li><code>-p ip::containerPort</code>：随机分配端口，例如 <code>-p 10.0.0.1::80</code></li>
<li><code>-p hostPort1:containerPort1 -p hostPort2:containerPort2</code>：指定多个端口映射，例如<code>-p 8080:80 -p 8888:3306</code></li>
</ul>
<h2 id="5-2-启动交互式容器"><a href="#5-2-启动交互式容器" class="headerlink" title="5.2 启动交互式容器"></a>5.2 启动交互式容器</h2><p>以交互方式启动ubuntu镜像</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-i 交互模式</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-t 分配一个伪输入终端<span class="built_in">tty</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ubuntu 镜像名称</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/bin/bash（或者bash） shell交互的接口</span></span><br><span class="line">docker run -it ubuntu /bin/bash</span><br></pre></td></tr></table></figure>

<p>退出交互模式：</p>
<p>方式1：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在交互shell中<span class="built_in">exit</span>即可退回宿主机</span></span><br><span class="line">exit;</span><br></pre></td></tr></table></figure>

<p>方式2：使用快捷键<code>ctrl</code> + <code>P</code> + <code>Q</code></p>
<blockquote>
<p>方式1 退出后，容器会停止；</p>
<p>方式2 退出后容器依然正在运行。</p>
</blockquote>
<h2 id="5-3-启动守护式容器"><a href="#5-3-启动守护式容器" class="headerlink" title="5.3 启动守护式容器"></a>5.3 启动守护式容器</h2><p>大部分情况下，我们系统docker容器服务时在后台运行的，可以通过<code>-d</code>指定容器的后台运行模式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d 容器名</span><br></pre></td></tr></table></figure>

<p><strong>注意事项：</strong></p>
<p>如果使用<code>docker run -d ubuntu</code>尝试启动守护式的ubuntu，会发现容器启动后就自动退出了。</p>
<p>因为Docker容器如果在后台运行，就必须要有一个前台进程。容器运行的命令如果不是那些一直挂起的命令（例如<code>top</code>、<code>tail</code>），就会自动退出。</p>
<h2 id="5-4-列出正在运行的容器"><a href="#5-4-列出正在运行的容器" class="headerlink" title="5.4 列出正在运行的容器"></a>5.4 列出正在运行的容器</h2><p>列出所有正在运行的容器：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps [OPTIONS]</span><br></pre></td></tr></table></figure>

<p>常用参数：</p>
<ul>
<li><code>-a</code>：列出当前所有正在运行的容器+历史上运行过的容器</li>
<li><code>-l</code>：显示最近创建的容器</li>
<li><code>-n</code>：显示最近n个创建的容器</li>
<li><code>-q</code>：静默模式，只显示容器编号</li>
</ul>
<h2 id="5-5-容器其他启停操作"><a href="#5-5-容器其他启停操作" class="headerlink" title="5.5 容器其他启停操作"></a>5.5 容器其他启停操作</h2><h3 id="5-5-1-启动已经停止的容器"><a href="#5-5-1-启动已经停止的容器" class="headerlink" title="5.5.1 启动已经停止的容器"></a>5.5.1 启动已经停止的容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start 容器ID或容器名</span><br></pre></td></tr></table></figure>

<h3 id="5-5-2-重启容器"><a href="#5-5-2-重启容器" class="headerlink" title="5.5.2 重启容器"></a>5.5.2 重启容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart 容器ID或容器名</span><br></pre></td></tr></table></figure>

<h3 id="5-5-3-停止容器"><a href="#5-5-3-停止容器" class="headerlink" title="5.5.3 停止容器"></a>5.5.3 停止容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop 容器ID或容器名</span><br></pre></td></tr></table></figure>

<h3 id="5-5-4-强制停止容器"><a href="#5-5-4-强制停止容器" class="headerlink" title="5.5.4 强制停止容器"></a>5.5.4 强制停止容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker kill 容器ID或容器名</span><br></pre></td></tr></table></figure>

<h3 id="5-5-5-删除容器"><a href="#5-5-5-删除容器" class="headerlink" title="5.5.5 删除容器"></a>5.5.5 删除容器</h3><p>删除已经停止的容器：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm 容器ID或容器名</span><br></pre></td></tr></table></figure>

<blockquote>
<p>删除容器是 <code>docker rm</code>，删除镜像是 <code>docker rmi</code>，注意区分。</p>
</blockquote>
<p>强制删除正在运行的容器：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -f 容器ID或容器名</span><br></pre></td></tr></table></figure>

<p>一次删除多个容器实例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker rm -f $&#123;docker ps -a -q&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或者</span></span><br><span class="line">docker ps -a -q | xargs docker rm</span><br></pre></td></tr></table></figure>



<h2 id="5-6-查看容器日志"><a href="#5-6-查看容器日志" class="headerlink" title="5.6 查看容器日志"></a>5.6 查看容器日志</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs 容器ID或容器名</span><br></pre></td></tr></table></figure>



<h2 id="5-7-查看容器内运行的进程"><a href="#5-7-查看容器内运行的进程" class="headerlink" title="5.7 查看容器内运行的进程"></a>5.7 查看容器内运行的进程</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker top 容器ID或容器名</span><br></pre></td></tr></table></figure>



<h2 id="5-8-查看容器内部细节"><a href="#5-8-查看容器内部细节" class="headerlink" title="5.8 查看容器内部细节"></a>5.8 查看容器内部细节</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect 容器ID或容器名</span><br></pre></td></tr></table></figure>



<h2 id="5-9-进入正在运行的容器"><a href="#5-9-进入正在运行的容器" class="headerlink" title="5.9 进入正在运行的容器"></a>5.9 进入正在运行的容器</h2><p>进入正在运行的容器，并以命令行交互：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it 容器ID bashShell</span><br></pre></td></tr></table></figure>

<p>重新进入：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker attach 容器ID</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>docker exec</code> 和 <code>docker attach</code> 区别：</p>
<ul>
<li><p><code>attach</code>直接进入容器启动命令的终端，不会启动新的进程，用<code>exit</code>退出会导致容器的停止</p>
</li>
<li><p><code>exec</code>是在容器中打开新的终端，并且可以启动新的进程，用<code>exit</code>退出不会导致容器的停止</p>
</li>
</ul>
</blockquote>
<p>如果有多个终端，都对同一个容器执行了 <code>docker attach</code>，就会出现类似投屏显示的效果。一个终端中输入输出的内容，在其他终端上也会同步的显示。</p>
<h2 id="5-10-容器和宿主机文件拷贝"><a href="#5-10-容器和宿主机文件拷贝" class="headerlink" title="5.10 容器和宿主机文件拷贝"></a>5.10 容器和宿主机文件拷贝</h2><p>容器内文件拷贝到宿主机：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp 容器ID:容器内路径 目的主机路径</span><br></pre></td></tr></table></figure>

<p>宿主机文件拷贝到容器中：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp 主机路径 容器ID:容器内路径</span><br></pre></td></tr></table></figure>



<h2 id="5-11-导入和导出容器"><a href="#5-11-导入和导出容器" class="headerlink" title="5.11 导入和导出容器"></a>5.11 导入和导出容器</h2><p><code>export</code>：导出容器的内容流作为一个tar归档文件（对应<code>import</code>命令）；</p>
<p><code>import</code>：从tar包中的内容创建一个新的文件系统再导入为镜像（对应<code>export</code>命令）；</p>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">导出</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker <span class="built_in">export</span> 容器ID &gt; tar文件名</span></span><br><span class="line">docker export abc &gt; aaa.tar</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">导入</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cat</span> tar文件 | docker import - 自定义镜像用户/自定义镜像名:自定义镜像版本号</span></span><br><span class="line">docker aaa.tar | docker import - test/mytest:1.0.1</span><br></pre></td></tr></table></figure>



<h2 id="5-12-将容器生成新镜像"><a href="#5-12-将容器生成新镜像" class="headerlink" title="5.12 将容器生成新镜像"></a>5.12 将容器生成新镜像</h2><p><code>docker commit</code>提交容器副本使之成为一个新的镜像。</p>
<blockquote>
<p>docker 启动一个镜像容器后， 可以在里面执行一些命令操作，然后使用<code>docker commit</code>将新的这个容器快照生成一个镜像。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit -m=&quot;提交的描述信息&quot; -a=&quot;作者&quot; 容器ID 要创建的目标镜像名:[tag]</span><br></pre></td></tr></table></figure>

<p>Docker挂载主机目录，可能会出现报错：<code>cannot open directory .: Perission denied</code>。</p>
<p>解决方案：在命令中加入参数 <code>--privileged=true</code>。</p>
<p>CentOS7安全模块比之前系统版本加强，不安全的会先禁止，目录挂载的情况被默认为不安全的行为，在SELinux里面挂载目录被禁止掉了。如果要开启，一般使用 <code>--privileged=true</code>，扩大容器的权限解决挂载没有权限的问题。也即使用该参数，容器内的root才拥有真正的root权限，否则容器内的root只是外部的一个普通用户权限。</p>
<h2 id="5-13-容器数据卷"><a href="#5-13-容器数据卷" class="headerlink" title="5.13 容器数据卷"></a>5.13 容器数据卷</h2><blockquote>
<p>卷就是目录或文件，存在于一个或多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能够绕过UnionFS，提供一些用于持续存储或共享数据。</p>
<p>特性：卷设计的目的就是数据的持久化，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂载的数据卷。</p>
</blockquote>
<p>特点:</p>
<ul>
<li>数据卷可以在容器之间共享或重用数据</li>
<li>卷中的更改可以直接实施生效</li>
<li>数据卷中的更改不会包含在镜像的更新中</li>
<li>数据卷的生命周期一直持续到没有容器使用它为止</li>
</ul>
<p>运行一个带有容器卷存储功能的容器实例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --privileged=true -v 宿主机绝对路径目录:容器内目录[rw | ro] 镜像名</span><br></pre></td></tr></table></figure>

<p>可以使用<code>docker inspect</code>查看容器绑定的数据卷。</p>
<p>权限：</p>
<ul>
<li><code>rw</code>：读写 </li>
<li><code>ro</code>：只读。如果宿主机写入内容，可以同步给容器内，容器内可以读取。</li>
</ul>
<p>容器卷的继承：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动一个容器</span></span><br><span class="line">docker run -it --privileged=true /tmp/test:/tmp/docker --name u1 ubuntu /bin/bash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用 --volumes-from 继承 u1的容器卷映射配置</span></span><br><span class="line">docker run -it --privileged=true --volumes-from u1 --name u2 ubuntu</span><br></pre></td></tr></table></figure>



<h2 id="5-14-所有命令示意图"><a href="#5-14-所有命令示意图" class="headerlink" title="5.14 所有命令示意图"></a>5.14 所有命令示意图</h2><img src="/post/f255ffad/1652093386636-41aec8f5-bd52-4a99-8c3c-daa61c1d78a5.png" class title="Docker-Command-Diagram.png">





<h1 id="6-Docker镜像"><a href="#6-Docker镜像" class="headerlink" title="6. Docker镜像"></a>6. Docker镜像</h1><h2 id="6-1-镜像"><a href="#6-1-镜像" class="headerlink" title="6.1 镜像"></a>6.1 镜像</h2><blockquote>
<p>镜像是一种轻量级、可执行的独立软件包，它包含运行某个软件所需的所有内容，我们把应用程序和配置依赖打包好行程一个可交付的运行环境（包括代码、运行时需要的库、环境变量和配置文件等），这个打包好的运行环境就是image镜像文件。</p>
</blockquote>
<h2 id="6-2-Docker-镜像加载原理"><a href="#6-2-Docker-镜像加载原理" class="headerlink" title="6.2 Docker 镜像加载原理"></a>6.2 Docker 镜像加载原理</h2><h3 id="6-2-1-联合文件系统"><a href="#6-2-1-联合文件系统" class="headerlink" title="6.2.1 联合文件系统"></a>6.2.1 联合文件系统</h3><blockquote>
<p>Docker 中的文件存储驱动叫做 storage driver。</p>
<p>Docker 最早支持的stotage driver是 AUFS，它实际上由一层一层的文件系统组成，这种层级的文件系统叫UnionFS。</p>
<p>联合文件系统（UnionFS）：Union 文件系统，是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下（unite serveral directories into a single virtual filesystem）。</p>
<p>Union文件系统是Docker镜像的基础。镜像可以通过分层来进行集成，基于基础镜像可以制作具体的应用镜像。</p>
<p>特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。</p>
<p>后来出现的docker版本中，除了AUFS，还支持OverlayFS、Btrfs、Device Mapper、VFS、ZFS等storage driver。</p>
</blockquote>
<h3 id="6-2-2-bootfs和rootfs"><a href="#6-2-2-bootfs和rootfs" class="headerlink" title="6.2.2 bootfs和rootfs"></a>6.2.2 bootfs和rootfs</h3><blockquote>
<p>bootfs（boot file system）主要包含 bootloader 和 kernel，bootloader主要是引导加载 kernel，Linux刚启动时会加载bootfs文件系统。</p>
<p>在Docker镜像的最底层是引导文件系统bootfs。这一层与我们典型的Linux&#x2F;Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已经由 bootfs 转交给内核，此时系统也会卸载 bootfs。</p>
<p>rootfs（root file system），在bootfs之上，包含的就是典型Linux系统中的 <code>/dev</code>、<code>/proc</code>、<code>/bin</code>、<code>/etc</code>等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu、CentOS等。</p>
<p>docker镜像底层层次：</p>
<img src="/post/f255ffad/1652093445038-27095471-f01f-4978-a28f-d8e2df893dab.jpeg" class title="layer01.jpg">

<p>对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令、工具和程序库就可以了，因为底层直接使用Host的Kernel，自己只需要提供rootfs就可以。所以，对于不同的Linux发行版，bootfs基本是一致的，rootfs会有差别，不同的发行版可以共用bootfs。</p>
<p>有差别的rootfs：</p>
<img src="/post/f255ffad/1652093452907-392b879e-1f7b-478a-97ae-7c37cb9669b3.jpeg" class title="layer02.jpg">


</blockquote>
<h2 id="6-3-镜像分层"><a href="#6-3-镜像分层" class="headerlink" title="6.3 镜像分层"></a>6.3 镜像分层</h2><p>Docker支持扩展现有镜像，创建新的镜像。新镜像是从base镜像一层一层叠加生成的。</p>
<p>例如：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Version: 0.0.1</span></span><br><span class="line"><span class="keyword">FROM</span> debian  <span class="comment"># 直接在debain base镜像上构建</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> mylinux</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y emacs <span class="comment"># 安装emacs</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install -y apache2 <span class="comment"># 安装apache2</span></span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;/bin/bash&quot;</span>] <span class="comment"># 容器启动时运行bash</span></span></span><br></pre></td></tr></table></figure>

<p>镜像创建过程：</p>
<img src="/post/f255ffad/1652093459380-335e0f0e-1213-47d9-a17b-f49734699ef2.png" class title="layer03.png">

<h2 id="6-4-镜像分层的优势"><a href="#6-4-镜像分层的优势" class="headerlink" title="6.4 镜像分层的优势"></a>6.4 镜像分层的优势</h2><p>镜像分层的一个最大好处就是共享资源，方便复制迁移，方便复用。</p>
<h2 id="6-5-容器层"><a href="#6-5-容器层" class="headerlink" title="6.5 容器层"></a>6.5 容器层</h2><p>当容器启动时，一个新的<strong>可写层</strong>将被加载到镜像的顶部，这一层通常被称为<code>容器层</code>，容器层之下的都叫<code>镜像层</code>。</p>
<p>所有对容器的改动，无论添加、删除、还是修改文件都只会发生在容器层中。</p>
<p>只有容器层是可写的，容器层下面的所有镜像层都是只读的。</p>
<p>如图：</p>
<img src="/post/f255ffad/1652093466220-a1c70673-7ca7-4025-9432-d89152439000.jpeg" class title="layer04.jpg">





<h1 id="7-Registry搭建docker私仓"><a href="#7-Registry搭建docker私仓" class="headerlink" title="7. Registry搭建docker私仓**"></a>7. Registry搭建docker私仓**</h1><h2 id="7-1-Docker-Registry"><a href="#7-1-Docker-Registry" class="headerlink" title="7.1 Docker Registry"></a>7.1 Docker Registry</h2><p>Docker Registry是官方提供的工具，用于构建私有镜像仓库。</p>
<h2 id="7-2-环境搭建"><a href="#7-2-环境搭建" class="headerlink" title="7.2 环境搭建"></a>7.2 环境搭建</h2><p>Docker Registry也是Docker Hub提供的一个镜像，可以直接拉取运行。</p>
<p>步骤：</p>
<ol>
<li><p>拉取镜像 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull registry</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动Docker Registry </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 5000:5000 -v /app/myregistry/:/tmp/registry --privileged=true registry</span><br></pre></td></tr></table></figure>
</li>
<li><p>验证（查看私服中的所有镜像）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://192.168.xxx.xxx:5000/v2/_catalog</span><br></pre></td></tr></table></figure></li>
</ol>
<p><code>Registry会返回json格式的所有镜像目录  </code></p>
<h2 id="7-3-向Registry私仓中上传镜像"><a href="#7-3-向Registry私仓中上传镜像" class="headerlink" title="7.3 向Registry私仓中上传镜像"></a>7.3 向Registry私仓中上传镜像</h2><h3 id="7-3-1-配置docker允许接收http请求"><a href="#7-3-1-配置docker允许接收http请求" class="headerlink" title="7.3.1 配置docker允许接收http请求"></a>7.3.1 配置docker允许接收<code>http</code>请求</h3><p>（配置方式和上传到nexus私仓相同）</p>
<p>修改<code>/etc/docker/daemon.json</code>，添加<code>insecure-registries</code>允许http：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;registry-mirros&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;https://xxxx.mirror.aliyuncs.com&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;insecure-registries&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;192.168.xxx.xxx:5000&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>然后重启docker：（新版本的docker会立即生效）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">centos6 的命令</span></span><br><span class="line">sudo chkconfig daemon-reload</span><br><span class="line">sudo service docker restart</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">centos7 的命令</span></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>

<h3 id="7-3-2-推送到私仓"><a href="#7-3-2-推送到私仓" class="headerlink" title="7.3.2 推送到私仓"></a>7.3.2 推送到私仓</h3><p>步骤：</p>
<ol>
<li><p>添加一个对应私仓地址的tag </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag lee/myubuntu:1.0.1 192.168.xxx.xxx:5000/lee/myubuntu:1.0.1</span><br></pre></td></tr></table></figure>
</li>
<li><p>push到私仓 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push 192.168.xxx.xxx:5000/lee/myubuntu:1.0.1</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看私仓中镜像目录验证</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://192.168.xxx.xxx:5000/v2/_catalog</span><br></pre></td></tr></table></figure>
</li>
<li><p>拉取验证：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull 192.169.xxx.xxx:5000/lee/myubuntu:1.0.1</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="8-Docker安装mysql"><a href="#8-Docker安装mysql" class="headerlink" title="8. Docker安装mysql"></a>8. Docker安装mysql</h1><p>以安装 Mysql 5.7为例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysql:5.7</span><br></pre></td></tr></table></figure>

<h2 id="8-1-mysql单机"><a href="#8-1-mysql单机" class="headerlink" title="8.1 mysql单机"></a>8.1 mysql单机</h2><h3 id="8-1-1-简单版-Mysql-5-7-安装"><a href="#8-1-1-简单版-Mysql-5-7-安装" class="headerlink" title="8.1.1 简单版 Mysql 5.7 安装"></a>8.1.1 简单版 Mysql 5.7 安装</h3><p>简单的启动Mysql容器：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">需要使用 -e 配置环境变量 MYSQL_ROOT_PASSWORD（mysql root用户的密码）</span></span><br><span class="line">docker run -p 3306:3306 -e MYSQL_ROOT_PASSWORD=root -d mysql:5.7</span><br></pre></td></tr></table></figure>

<p>简单版的Mysql会存在以下问题：</p>
<ul>
<li>中文乱码</li>
<li>没有容器卷映射</li>
</ul>
<p>启动docker容器后，可以正常的连接、创建数据库，创建表，插入数据。但是插入中文则会报错。</p>
<p>例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建db01数据库</span></span><br><span class="line"><span class="keyword">create</span> database db01;</span><br><span class="line"><span class="comment">-- 切换到db01;</span></span><br><span class="line">use db01;</span><br><span class="line"><span class="comment">-- 创建表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t1(id <span class="type">int</span>, name <span class="type">varchar</span>(<span class="number">20</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入英文可以正常插入</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t1 <span class="keyword">values</span>(<span class="number">1</span>, <span class="string">&#x27;abc&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入中文报错</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t1 <span class="keyword">values</span>(<span class="number">2</span>, <span class="string">&#x27;张三&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>这是因为docker默认的字符集的问题，可以在mysql中使用以下命令查看数据库字符集：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;character%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>返回的字符集中，<code>character_set_database</code>、<code>character_set_server</code>等都为<code>latin1</code>字符集，所以会报错。</p>
<p>而且因为启动容器时没有配置容器卷映射，当容器意外被删时，数据无法找回。</p>
<h3 id="8-1-2-实际应用版-Mysql-5-7安装"><a href="#8-1-2-实际应用版-Mysql-5-7安装" class="headerlink" title="8.1.2 实际应用版 Mysql 5.7安装"></a>8.1.2 实际应用版 Mysql 5.7安装</h3><p>启动 Mysql 容器，并配置容器卷映射：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 3306:3306 \</span><br><span class="line">           --privileged=true \</span><br><span class="line">           -v /app/mysql/log:/var/log/mysql \</span><br><span class="line">           -v /app/mysql/data:/var/lib/mysql \</span><br><span class="line">           -v /app/mysql/conf:/etc/mysql/conf.d \</span><br><span class="line">           -e MYSQL_ROOT_PASSWORD=root \</span><br><span class="line">           --name mysql \</span><br><span class="line">           mysql:5.7</span><br></pre></td></tr></table></figure>

<p>在<code>/app/mysql/conf</code>下新建 <code>my.cnf</code>，通过容器卷同步给mysql实例，解决中文乱码问题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[client]</span><br><span class="line">default_character_set=utf8</span><br><span class="line">[mysqld]</span><br><span class="line">collation_server = utf8_general_ci</span><br><span class="line">character_set_server = utf8</span><br></pre></td></tr></table></figure>

<p>重启mysql容器，使得容器重新加载配置文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart mysql</span><br></pre></td></tr></table></figure>

<p>此时便解决了中文乱码（中文插入报错）问题。</p>
<p>而且因为启动时将容器做了容器卷映射，将mysql的配置（映射到<code>/app/mysql/conf</code>）、数据（映射到<code>/app/mysql/data</code>）、日志（映射到<code>/app/mysql/log</code>）都映射到了宿主机实际目录，所以即使删除了容器，也不会产生太大影响。只需要再执行一下启动Mysql容器命令，容器卷还按相同位置进行映射，所有的数据便都可以正常恢复。</p>
<h2 id="8-2-Mysql-主从复制安装"><a href="#8-2-Mysql-主从复制安装" class="headerlink" title="8.2 Mysql 主从复制安装"></a>8.2 Mysql 主从复制安装</h2><p>安装主服务器容器实例（端口号3307）：</p>
<ol>
<li><p>启动容器实例 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 3307:3306 \</span><br><span class="line">           --name mysql-master \</span><br><span class="line">           --privileged=true \</span><br><span class="line">           -v /app/mysql-master/log:/var/log/mysql \</span><br><span class="line">           -v /app/mysql-master/data:/var/lib/mysql \</span><br><span class="line">           -v /app/mysql-master/conf:/etc/mysql \</span><br><span class="line">           -e MYSQL_ROOT_PASSWORD=root \</span><br><span class="line">           -d mysql:5.7</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入<code>/app/mysql-master/conf</code>，新建<code>my.cnf</code>配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">## 设置server_id, 同一个局域网中需要唯一</span><br><span class="line">server_id=101</span><br><span class="line">## 指定不需要同步的数据库名称</span><br><span class="line">binlog-ignore-db=mysql</span><br><span class="line">## 开启二进制日志功能</span><br><span class="line">log-bin=mall-mysql-bin</span><br><span class="line">## 设置二进制日志使用内存大小（事务）</span><br><span class="line">binlog_cache_size=1M</span><br><span class="line">## 设置使用的二进制日志格式（mixed,statement,row）</span><br><span class="line">binlog_format=mixed</span><br><span class="line">## 二进制日志过期清理时间。默认值为0，表示不自动清理</span><br><span class="line">expire_logs_days=7</span><br><span class="line">## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断</span><br><span class="line">## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致</span><br><span class="line">slave_skip_errors=1062</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启容器实例 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart mysql-master</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入容器实例内 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mysql-master /bin/bash</span><br></pre></td></tr></table></figure>
</li>
<li><p>登录mysql，创建数据同步用户 </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 首先使用 mysql -uroot -p 登录mysql</span></span><br><span class="line"><span class="comment">-- 创建数据同步用户</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">&#x27;slave&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line"><span class="comment">-- 授权</span></span><br><span class="line"><span class="keyword">grant</span> replication slave, replication client <span class="keyword">on</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;slave&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>安装从服务器容器实例（端口号3308）：</p>
<ol>
<li><p>启动容器服务： </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 3308:3306 \</span><br><span class="line">           --name mysql-slave \</span><br><span class="line">           --privileged=true \</span><br><span class="line">           -v /app/mysql-slave/log:/var/log/mysql \</span><br><span class="line">           -v /app/mysql-slave/data:/var/lib/mysql \</span><br><span class="line">           -v /app/mysql-slave/conf:/etc/mysql \</span><br><span class="line">           -e MYSQL_ROOT_PASSWORD=root \</span><br><span class="line">           -d mysql:5.7</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入<code>/app/mysql-slave/conf</code>目录，创建<code>my.cnf</code>配置文件： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">## 设置server_id, 同一个局域网内需要唯一</span><br><span class="line">server_id=102</span><br><span class="line">## 指定不需要同步的数据库名称</span><br><span class="line">binlog-ignore-db=mysql</span><br><span class="line">## 开启二进制日志功能，以备slave作为其它数据库实例的Master时使用</span><br><span class="line">log-bin=mall-mysql-slave1-bin</span><br><span class="line">## 设置二进制日志使用内存大小（事务）</span><br><span class="line">binlog_cache_size=1M</span><br><span class="line">## 设置使用的二进制日志格式（mixed,statement,row）</span><br><span class="line">binlog_format=mixed</span><br><span class="line">## 二进制日志过期清理时间。默认值为0，表示不自动清理</span><br><span class="line">expire_logs_days=7</span><br><span class="line">## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断</span><br><span class="line">## 如：1062错误是指一些主键重复，1032是因为主从数据库数据不一致</span><br><span class="line">slave_skip_errors=1062</span><br><span class="line">## relay_log配置中继日志</span><br><span class="line">relay_log=mall-mysql-relay-bin</span><br><span class="line">## log_slave_updates表示slave将复制事件写进自己的二进制日志</span><br><span class="line">log_slave_updates=1</span><br><span class="line">## slave设置只读（具有super权限的用户除外）</span><br><span class="line">read_only=1</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改完配置需要重启slave容器实例 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart mysql-slave</span><br></pre></td></tr></table></figure></li>
</ol>
<p>在主数据库中查看主从同步状态：</p>
<ol>
<li><p>进入主数据库容器： </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mysql-master /bin/bash</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入Mysql</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看主从同步状态 </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> master status;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>主要查看返回结果的文件名<code>File</code>、当前位置<code>Position</code> </p>
<p>进入从数据库容器，配置主从复制：</p>
<ol>
<li><p>进入从数据库容器： </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mysql-slave /bin/bash</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入数据库 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置从数据库所属的主数据库： </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 格式：</span></span><br><span class="line"><span class="comment">-- change master to master_host=&#x27;宿主机ip&#x27;,master_user=&#x27;主数据库配置的主从复制用户名&#x27;,master_password=&#x27;主数据库配置的主从复制用户密码&#x27;,master_port=宿主机主数据库端口,master_log_file=&#x27;主数据库主从同步状态的文件名File&#x27;,master_log_pos=主数据库主从同步状态的Position,master_connect_retry=连接失败重试时间间隔（秒）;</span></span><br><span class="line"></span><br><span class="line">change master <span class="keyword">to</span> master_host<span class="operator">=</span><span class="string">&#x27;192.168.xxx.xxx&#x27;</span>,master_user<span class="operator">=</span><span class="string">&#x27;slave&#x27;</span>,master_password<span class="operator">=</span><span class="string">&#x27;123456&#x27;</span>,master_port<span class="operator">=</span><span class="number">3307</span>,master_log_file<span class="operator">=</span><span class="string">&#x27;mall-mysql-bin.000001&#x27;</span>,master_log_pos<span class="operator">=</span><span class="number">769</span>,master_connect_retry<span class="operator">=</span><span class="number">30</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看主从同步状态：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># \G 可以将横向的结果集表格转换成纵向展示。</span><br><span class="line"># slave status的字段比较多，纵向展示比友好</span><br><span class="line"><span class="keyword">show</span> slave status \G;</span><br></pre></td></tr></table></figure>

<p>除了展示刚刚配置的主数据库信息外，主要关注 <code>Slave_IO_Running</code>、<code>Slave_SQL_Running</code>。目前两个值应该都为 <code>No</code>，表示还没有开始。 </p>
</li>
<li><p>开启主从同步：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> slave;</span><br></pre></td></tr></table></figure>
</li>
<li><p>再次查看主从同步状态，<code>Slave_IO_Running</code>、<code>Slave_SQL_Running</code>都变为<code>Yes</code>。</p>
</li>
</ol>
<p>主从复制测试：</p>
<ol>
<li><p>在主数据库上新建库、使用库、新建表、插入数据 </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> database db01;</span><br><span class="line">use db01;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t1 (id <span class="type">int</span>, name <span class="type">varchar</span>(<span class="number">20</span>));</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t1 <span class="keyword">values</span> (<span class="number">1</span>, <span class="string">&#x27;abc&#x27;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>在从数据库上使用库、查看记录 </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> databases;</span><br><span class="line">use db01;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="9-Docker安装Redis"><a href="#9-Docker安装Redis" class="headerlink" title="9. Docker安装Redis"></a>9. Docker安装Redis</h1><p>以 Redis 6.0.8 为例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull redis:6.0.8</span><br></pre></td></tr></table></figure>



<h2 id="9-1-单机版安装"><a href="#9-1-单机版安装" class="headerlink" title="9.1 单机版安装"></a>9.1 单机版安装</h2><h3 id="9-1-1-简单版-Redis"><a href="#9-1-1-简单版-Redis" class="headerlink" title="9.1.1 简单版 Redis"></a>9.1.1 简单版 Redis</h3><p>简单的启动Redis容器：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 6379:6379 -d redis:6.0.8</span><br></pre></td></tr></table></figure>

<p>简单版没有配置容器卷映射，当容器被删除时数据无法恢复。</p>
<h3 id="9-1-2-实际应用版Redis"><a href="#9-1-2-实际应用版Redis" class="headerlink" title="9.1.2 实际应用版Redis"></a>9.1.2 实际应用版Redis</h3><p>配置文件、数据文件都和容器卷进行映射。</p>
<p>步骤：</p>
<ol>
<li><p>宿主机创建目录<code>/app/redis</code></p>
</li>
<li><p>在<code>/app/redis</code>下创建文件<code>redis.conf</code>，主要修改以下几项配置 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开启密码验证（可选）</span></span><br><span class="line">requirepass 123</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">允许redis外地连接，需要注释掉绑定的IP</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">bind</span> 127.0.0.1</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关闭保护模式（可选）</span></span><br><span class="line">protected-mode no</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注释掉daemonize <span class="built_in">yes</span>，或者配置成 daemonize no。因为该配置和 docker run中的 -d 参数冲突，会导致容器一直启动失败</span></span><br><span class="line">daemonize no</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开启redis数据持久化， （可选）</span></span><br><span class="line">appendonly yes</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动docker容器：（因为要使用自定义的配置文件，所以需要指定容器运行的命令为<code>redis-server 容器内配置文件路径</code>） </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 6379:6379 --name redis --privileged=true \</span><br><span class="line">           -v /app/redis/redis.conf:/etc/redis/redis.conf \</span><br><span class="line">           -v /app/redis/data:/data \</span><br><span class="line">           redis:6.0.8 \</span><br><span class="line">         </span><br><span class="line">         redis-server /etc/redis/redis.conf</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="9-2-集群存储算法"><a href="#9-2-集群存储算法" class="headerlink" title="9.2 集群存储算法"></a>9.2 集群存储算法</h2><p>分布式存储的常见算法：</p>
<ul>
<li>哈希取余算法分区</li>
<li>一致性哈希算法分区</li>
<li>哈希槽算法分区</li>
</ul>
<h3 id="9-2-1-哈希取余算法"><a href="#9-2-1-哈希取余算法" class="headerlink" title="9.2.1 哈希取余算法"></a>9.2.1 哈希取余算法</h3><blockquote>
<p>算法描述：<code>hash(key) % N</code>（其中，<code>key</code>是要存入Redis的键名，<code>N</code>是Redis集群的机器台数）。用户每次读写操作，都是根据传入的键名经过哈希运算，对机器台数取余决定该键存储在哪台服务器上。</p>
<p>优点：简单直接有效，只需要预估好数据规划好节点，就能保证一段时间的数据支撑。使用Hash算法让固定的一部分请求落到同一台服务器上，这样每台服务器固定处理一部分请求（并维护这些请求的信息），起到负载均衡+分而治之的作用。</p>
<p>缺点：原来规划好的节点，如果进行了扩容或者缩容，导致节点有变动，映射关系需要重新进行计算。在服务器个数固定不变时没问题，如果需要弹性扩容或者故障停机的情况下，原来取模公式中的 <code>N</code>就会发生变化，此时经过取模运算的结果就会发生很大变化，导致根据公式获取的服务器变得不可控。</p>
</blockquote>
<h3 id="9-2-2-一致性哈希算法"><a href="#9-2-2-一致性哈希算法" class="headerlink" title="9.2.2 一致性哈希算法"></a>9.2.2 一致性哈希算法</h3><blockquote>
<p>算法背景：一致性哈希算法是<strong>为了解决哈希取余算法中的分布式缓存数据变动和映射问题</strong>。当服务器个数发生变化时，尽量减少影响到客户端与服务器的映射关系。</p>
<p>算法描述：</p>
<p>一致性哈希算法必然有个hash函数并按照算法产生Hash值，这个算法的所有可能哈希值会构成一个全量集，这个集合可以成为一个Hash区间<code>[0, 2^32 - 1]</code>，这是一个线性空间。但是在这个算法中，我们通过适当的逻辑控制将它首尾相连（<code>0 = 2^32</code>），这样让它逻辑上形成了一个环形空间。</p>
<p>它也是按照使用取模的方式。前面的哈希取余算法是对节点个数进行取模，而一致性哈希算法是对 <code>2^32</code>取模。</p>
<p>简单来说，一致性Hash算法将整个哈希值空间组成一个虚拟的圆环。如假设某个哈希函数<code>H</code>的值空间为 <code>0</code>到<code>2^32 - 1</code>（即哈希值是一个32位无符号整形），整个哈希环如下图：整个空间按顺时针方向组织，圆环的正上方的点代表0，0点右侧的第一个点代表1，以此类推，2、3、4…….直到<code>2^32 - 1</code>，也就是说0点左侧的第一个点代表 <code>2^32 - 1</code>。0 和 <code>2^32 - 1</code>在零点钟方向重合，我们把这个由 <code>2^32</code>个点组成的圆环称为Hash环。</p>
<img src="/post/f255ffad/1652093509506-9d93249f-ba00-4339-b28d-5333d93b0356.jpeg" class title="hash01.jpg">

<p>有了哈希环之后，还需要进行节点映射，将集群中各个IP节点映射到环上的某一个位置。</p>
<p>将各个服务器使用Hash进行一个哈希，具体可以选择服务器的IP或主机名作为关键字进行哈希。这样每台机器就能确定其在哈希环上的位置。</p>
<p>假如4个节点NodeA、B、C、D，经过IP地址的哈希函数计算（<code>hash(ip)</code>），使用IP地址哈希值后在环空间的位置如下：</p>
<img src="/post/f255ffad/1652093520104-5b400131-e3ea-4b37-8e53-e6c59e81fcb3.jpeg" class title="hash02.jpg">

<p><code>key</code>落到服务器的落键规则。当我们需要存储一个<code>key</code>键值对时，首先计算<code>key</code>的<code>hash</code>值（<code>hash(key)</code>），将这个<code>key</code>使用相同的函数hash，计算出哈希值并确定此数据在环上的位置，从此位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器，并将该键值对存储字该节点上。</p>
<p>假如我们有ObjectA、B、C、D四个数据对象，经过哈希计算后，在环空间上的位置如下：根据一致性hash算法，数据A会被定位到NodeA上，B被定位到NodeB上，C被定位到NodeC上，D被定位到NodeD上。</p>
<img src="/post/f255ffad/1652093529336-8a318268-7d45-44b7-a038-39c99d6598f3.jpeg" class title="hash03.jpg">

<p>假设NodeC宕机，可以看到此时对象A、B、D不会受到影响，只有C对象被重新定位到NodeD。</p>
<p>一般的，在一致性Hash算法中，如果一台服务器不可用，则受影响的数据仅仅是此服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间的数据，其他不会受到影响。</p>
<p>即：假设NodeC宕机，只会影响到Hash定位到NodeB到NodeC之间的数据，并且这些数据会被转移到NodeD进行存储。</p>
<img src="/post/f255ffad/1652093568315-79bb50cb-c3ca-45f3-b2b8-21cd2bdd7ea6.jpeg" class title="hash04.jpg">

<p>假如需要扩容增加一台节点NodeX，NodeX的<code>hash(ip)</code>位于NodeB和NodeC之间，那受到影响的就是NodeB 到 NodeX 之间的数据。重新将B到X的数据录入到X节点上即可，不会导致Hash取余全部数据重新洗牌的后果。</p>
<img src="/post/f255ffad/1652093600085-007ad642-e950-40f4-9470-2a4f3b0c3037.jpeg" class title="hash05.jpg">

<p>但是Hash环会存在数据倾斜问题。</p>
<p>一致性Hash算法在服务节点太少时，容易因为节点分布不均匀而造成数据倾斜（被缓存的对象都集中到某一台或某几台服务器）。</p>
<img src="/post/f255ffad/1652093608796-1e42d92f-21c3-44d8-af84-5cab7666b25a.webp" class title="hash06.webp">

<p>为了解决数据倾斜问题，一致性哈希算法引入了虚拟节点机制。</p>
<p>对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。具体做法可以先确定每个物理节点关联的虚拟节点数量，然后在IP或主机名后面加上编号。</p>
<p>例如，可以对NodeA节点虚拟出 NodeA#1、NodeA#2、NodeA#3，对NodeB虚拟出NodeB#1、NodeB#2、NodeB#3的节点，形成六个虚拟节点。</p>
<img src="/post/f255ffad/1652093615343-e8253b84-6085-4368-9853-29ec0e26b10a.jpeg" class title="hash07.jpg">

<p>优点：加入和删除节点时，只会影响哈希环中顺时针方向相邻节点，对其他节点无影响。</p>
<p>缺点：数据的分布和节点的位置有关，因为这些节点不是均匀分布在哈希环上的，所以在数据进行存储时达不到均匀部分的效果。</p>
</blockquote>
<h3 id="9-2-3-哈希槽分区"><a href="#9-2-3-哈希槽分区" class="headerlink" title="9.2.3 哈希槽分区"></a>9.2.3 哈希槽分区</h3><blockquote>
<p>哈希槽分区是为了解决一致性哈希算法的数据倾斜问题。</p>
<p>哈希槽实质上就是一个数组，数组 <code>[0, 2^14 - 1]</code>形成的 hash slot空间。</p>
<p>目的是为了解决均匀分配的问题。在数据和节点之间又加入了一层，把这层称之为槽（slot），用于管理数据和节点之间的关系。就相当于节点上放的是槽，槽里面放的是数据。</p>
<img src="/post/f255ffad/1652093624003-4b618ccd-4ac1-4ddb-8ff5-665da31781ea.png" class title="slot01.png">

<p>槽解决的是粒度问题，相当于把粒度变大了，这样便于数据移动。</p>
<p>哈希解决的是映射问题，使用<code>key</code>的哈希值来计算所在的槽，便于数据分配。</p>
<p>一个集群只能有 16394个槽，编号 0 - 16383（<code>2^14 - 1</code>）。这些槽会分配给集群中所有的主节点，分配策略没有要求。可以指定哪些编号的槽分配给哪个主节点，集群会记录节点和槽的对应关系。</p>
<p>解决了节点和槽的关系后，接下来就需要对<code>key</code>求哈希值，然后对16384取余，根据余数决定<code>key</code>落到哪个槽里。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">slot = CRC16(key) % 16384</span></span><br></pre></td></tr></table></figure>

<p>以槽为单位移动数据，因为槽的数目是固定的，处理起来比较容易，这样数据移动问题就解决了。</p>
</blockquote>
<h2 id="9-3-Redis集群存储策略"><a href="#9-3-Redis集群存储策略" class="headerlink" title="9.3 Redis集群存储策略"></a>9.3 Redis集群存储策略</h2><p>Redis集群使用的就是哈希槽。Redis集群有16384个哈希槽，每个<code>key</code>通过<code>CRC16</code>校验后对16384取模来决定放置在哪个槽，集群的每个节点负责一部分hash槽。</p>
<p>哈希槽数量16384（<code>2^14</code>）的决定原因：</p>
<p><code>CRC16</code>算法产生的hash值有 16bit，该算法可以产生 <code>2^16</code> &#x3D; 65536个值。但是为了心跳方便和数据传输最大化，槽的数量只能有 <code>2^14</code>个。</p>
<ol>
<li><p>如果槽位数量为65535个，那么发送心跳信息的消息头将达到 8k，发送的心跳包过于庞大。在消息头中最占空间的是 <code>myslots[CLUSTER_SLOTS/8]</code>。当槽位为65536时，这块的大小是 ： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">65536 ÷ 8 ÷ 1024 = 8Kb</span><br></pre></td></tr></table></figure></li>
</ol>
<p>每秒中redis节点需要发送一定数量的ping消息作为心跳，如果槽位为65536，那么这个ping消息头就会太大浪费带宽。 </p>
<ol start="2">
<li>redis集群的主节点数量基本不可能超过1000个。集群节点越多，心跳包的消息体内携带的数据越多。如果节点超过1000个，也会导致网络拥堵。因此redis作者不建议redis cluster节点超过1000个。对于节点数在1000以内的redis cluster集群，16384个槽位足够了，没有必要扩展到65536个。</li>
<li>槽位越小，节点少的情况下压缩比越高，容易传输。Redis主节点的配置信息中它锁负责的哈希槽是通过一张bitmap的形式来保存的，在传输过程中会对bitmap进行压缩，但是如果bitmap的填充率 <code>slots / N</code>（N为节点数）很高的话，bitmap的压缩率就很低。如果节点数很少，而哈希槽数很多的话，bitmap的压缩率就很低。</li>
</ol>
<blockquote>
<p>原文：</p>
<p>正常的心跳数据包带有节点的完整配置，使得可以用幂等方式用旧的节点替换旧节点，以便更新旧的配置。这意味着它们包含原始节点的插槽配置，该节点使用 2k 的空间和 16k 的插槽，而不是使用 8k 的空间（使用65k的插槽）。</p>
<p>同时，因为其他设计折衷，Redis集群的主节点不太可能扩展到1000个以上</p>
</blockquote>
<p>Redis集群中内置了16384个哈希槽，redis会根据节点数量大致均等的将哈希槽映射到不同的节点。当需要在Redis集群中放置一个<code>Key-Value</code>时，redis先对<code>key</code>使用 <code>CRC16</code> 算法算出一个结果，然后把结果对 16384 取余，这样每个<code>key</code>都会对应一个编号在0-16383之间的哈希槽，也就是映射到某个节点上。</p>
<img src="/post/f255ffad/1652093634015-d8b7b188-0beb-4d34-a025-3eade79bb6bb.png" class title="slot02.png">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// import io.lettuce.core.cluster.SlotHash;</span></span><br><span class="line">    System.out.println(SlotHash.getSlot(<span class="string">&#x27;A&#x27;</span>));  <span class="comment">// 计算结果6373，存入上图的Node2</span></span><br><span class="line">    System.out.println(SlotHash.getSlot(<span class="string">&#x27;B&#x27;</span>));  <span class="comment">// 计算结果10374，存入上图的Node2</span></span><br><span class="line">    System.out.println(SlotHash.getSlot(<span class="string">&#x27;C&#x27;</span>));  <span class="comment">// 计算结果14503，存入上图的Node3</span></span><br><span class="line">    System.out.println(SlotHash.getSlot(<span class="string">&#x27;Hello&#x27;</span>));  <span class="comment">// 计算结果866，存入上图的Node1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="9-4-3主3从Redis集群"><a href="#9-4-3主3从Redis集群" class="headerlink" title="9.4 3主3从Redis集群"></a>9.4 3主3从Redis集群</h2><h3 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h3><p>使用docker搭建3主3从的Redis集群，每台主机都对应一台从机。</p>
<p>启动6台redis容器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动第1台节点</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--net host 使用宿主机的IP和端口，默认</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--cluster-enabled <span class="built_in">yes</span> 开启redis集群</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--appendonly <span class="built_in">yes</span> 开启redis持久化</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--port 6381 配置redis端口号</span></span><br><span class="line">docker run -d --name redis-node-1 --net host --privileged=true -v /app/redis-cluster/share/redis-node-1:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6381</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动第2台节点</span></span><br><span class="line">docker run -d --name redis-node-2 --net host --privileged=true -v /app/redis-cluster/share/redis-node-2:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6382</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动第3台节点</span></span><br><span class="line">docker run -d --name redis-node-3 --net host --privileged=true -v /app/redis-cluster/share/redis-node-3:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6383</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动第4台节点</span></span><br><span class="line">docker run -d --name redis-node-4 --net host --privileged=true -v /app/redis-cluster/share/redis-node-4:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6384</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动第5台节点</span></span><br><span class="line">docker run -d --name redis-node-5 --net host --privileged=true -v /app/redis-cluster/share/redis-node-5:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6385</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动第6台节点</span></span><br><span class="line">docker run -d --name redis-node-6 --net host --privileged=true -v /app/redis-cluster/share/redis-node-6:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6386</span><br></pre></td></tr></table></figure>

<p>构建主从关系：</p>
<ol>
<li><p>进入节点1（或其中任意一个节点）: </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it redis-node-1 /bin/bash</span><br></pre></td></tr></table></figure>
</li>
<li><p>构建主从关系： </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">宿主机IP:端口</span></span><br><span class="line">redis-cli --cluster create 192.168.xxx.xxx:6381 192.168.xxx.xxx:6382 192.168.xxx.xxx:6383 192.168.xxx.xxx:6384 192.168.xxx.xxx:6385 192.168.xxx.xxx:6386 --cluster-replicas 1</span><br></pre></td></tr></table></figure>
</li>
<li><p>redis尝试自动进行主从节点分配 </p>
</li>
<li><p>因为我们的docker容器IP相同，所以会出现警告，可以直接忽略该警告</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[WARNING] Some slaves are in the same host as their master</span><br></pre></td></tr></table></figure>
</li>
<li><p>redis自动分配结果完成后，需要输入 <code>Yes</code> 确认配置信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">M: f451eb48bbc0a7c31c7da022ffe80cc1696e0f37 192.168.xxx.xxx:6381</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">M: 05984211b8c38222a73abeff1d4e459c0fe1efbc 192.168.xxx.xxx:6382</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">M: 1fc935c12b1d34a7df50aed643c195eb29bb3435 192.168.xxx.xxx:6383</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">S: f8d0de47114bf33438747acd713cce4e412ae721 192.168.xxx.xxx:6384</span><br><span class="line">   replicates 1fc935c12b1d34a7df50aed643c195eb29bb3435</span><br><span class="line">S: de0b393c17e452d856f6de2b348e9ca4e5aa4002 192.168.xxx.xxx:6385</span><br><span class="line">   replicates f451eb48bbc0a7c31c7da022ffe80cc1696e0f37</span><br><span class="line">S: 0c0767e13a09ee48541738d4163592cd9842c143 192.168.xxx.xxx:6386</span><br><span class="line">   replicates 05984211b8c38222a73abeff1d4e459c0fe1efbc</span><br><span class="line">Can I set the above configuration? (type &#x27;yes&#x27; to accept):</span><br></pre></td></tr></table></figure>
</li>
<li><p>输入<code>Yes</code>确认后，redis会向其他节点发送信息加入集群，并分配哈希槽：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; Nodes configuration updated</span><br><span class="line">&gt;&gt;&gt; Assign a different config epoch to each node</span><br><span class="line">&gt;&gt;&gt; Sending CLUSTER MEET messages to join the cluster</span><br><span class="line">Waiting for the cluster to join</span><br><span class="line">.....</span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node 192.168.xxx.xxx:6381)</span><br><span class="line">M: f451eb48bbc0a7c31c7da022ffe80cc1696e0f37 192.168.xxx.xxx:6381</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: 1fc935c12b1d34a7df50aed643c195eb29bb3435 192.168.xxx.xxx:6383</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: 05984211b8c38222a73abeff1d4e459c0fe1efbc 192.168.xxx.xxx:6382</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 0c0767e13a09ee48541738d4163592cd9842c143 192.168.xxx.xxx:6386</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 05984211b8c38222a73abeff1d4e459c0fe1efbc</span><br><span class="line">S: f8d0de47114bf33438747acd713cce4e412ae721 192.168.xxx.xxx:6384</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 1fc935c12b1d34a7df50aed643c195eb29bb3435</span><br><span class="line">S: de0b393c17e452d856f6de2b348e9ca4e5aa4002 192.168.xxx.xxx:6385</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates f451eb48bbc0a7c31c7da022ffe80cc1696e0f37</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check for open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure>

<p>查看集群状态：</p>
<ol>
<li><p>进入容器节点1（或集群中其他节点）： </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it redis-node-1 /bin/bash</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>redis-cli</code>连接到<code>6381</code>节点： </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 6381</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>redis</code>的相关命令查看集群状态： </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster info</span><br></pre></td></tr></table></figure>

<p>其中，分配的哈希槽数量 <code>cluster_slots_assigned</code>为16384，集群节点数量<code>cluster_known_nodes</code>为6 </p>
</li>
<li><p>查看集群节点信息 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster nodes</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h2 id="9-5-Redis集群读写出错"><a href="#9-5-Redis集群读写出错" class="headerlink" title="9.5 Redis集群读写出错"></a>9.5 Redis集群读写出错</h2><p>当使用 <code>redis-cli</code>连接redis集群时，需要添加 <code>-c</code>参数，否则可能会出现读写出错。</p>
<p>示例：</p>
<ol>
<li><p>进入容器节点1 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it redis-node-1 /bin/bash</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>redis-cli</code>连接，不加<code>-c</code>参数时</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 6381</span><br></pre></td></tr></table></figure>
</li>
<li><p>此时向redis中添加键值对，可能会成功，也可能会失败</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set k1 v1</span><br></pre></td></tr></table></figure></li>
</ol>
<p>报错：<code>k1</code>经过计算得到的哈希槽为12706，但是当前连接的redis-server为<code>6381</code>（即节点1），它的哈希槽为：<code>[0,5460]</code>（在创建构建主从关系时redis有提示，也可以通过 <code>cluster nodes</code>查看），所以会因为存不进去而报错。<br>执行 <code>set k2 v2</code>可以成功，因为<code>k2</code>计算出的哈希槽在<code>[0-5460]</code>区间中。 </p>
<ol start="4">
<li><p>使用<code>-c</code>参数的<code>redis-cli</code>命令连接即可 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 6381 -c</span><br></pre></td></tr></table></figure>
</li>
<li><p>此时可以正常的插入所有数据 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set k1 v1</span><br></pre></td></tr></table></figure></li>
</ol>
<p>会有提示信息，哈希槽为12706，重定向到<code>6383</code>（即节点3，哈希槽<code>[10923, 16383]</code>）：  </p>
<h2 id="9-6-集群信息检查"><a href="#9-6-集群信息检查" class="headerlink" title="9.6 集群信息检查"></a>9.6 集群信息检查</h2><p>检查查看集群信息：</p>
<ol>
<li><p>进入容器节点1 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it redis-node-1 /bin/bash</span><br></pre></td></tr></table></figure>
</li>
<li><p>进行集群信息检查 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输入任意一台主节点地址都可以进行集群检查</span></span><br><span class="line">redis-cli --cluster check 192.168.xxx.xxx:6381</span><br></pre></td></tr></table></figure></li>
</ol>
<p>返回的检查结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">当前集群中各个节点存储的key的数量</span><br><span class="line">192.168.xxx.xxx:6381 (f451eb48...) -&gt; 0 keys | 5461 slots | 1 slaves.</span><br><span class="line">192.168.xxx.xxx:6383 (1fc935c1...) -&gt; 1 keys | 5461 slots | 1 slaves.</span><br><span class="line">192.168.xxx.xxx:6382 (05984211...) -&gt; 0 keys | 5462 slots | 1 slaves.</span><br><span class="line">[OK] 1 keys in 3 masters.  </span><br><span class="line">0.00 keys per slot on average.</span><br><span class="line"></span><br><span class="line">主从机器信息</span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node 192.168.xxx.xxx:6381)</span><br><span class="line">M: f451eb48bbc0a7c31c7da022ffe80cc1696e0f37 192.168.xxx.xxx:6381</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: 1fc935c12b1d34a7df50aed643c195eb29bb3435 192.168.xxx.xxx:6383</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: 05984211b8c38222a73abeff1d4e459c0fe1efbc 192.168.xxx.xxx:6382</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 0c0767e13a09ee48541738d4163592cd9842c143 192.168.xxx.xxx:6386</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 05984211b8c38222a73abeff1d4e459c0fe1efbc</span><br><span class="line">S: f8d0de47114bf33438747acd713cce4e412ae721 192.168.xxx.xxx:6384</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 1fc935c12b1d34a7df50aed643c195eb29bb3435</span><br><span class="line">S: de0b393c17e452d856f6de2b348e9ca4e5aa4002 192.168.xxx.xxx:6385</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates f451eb48bbc0a7c31c7da022ffe80cc1696e0f37</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check for open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure>



<h2 id="9-7-主从扩容缩容"><a href="#9-7-主从扩容缩容" class="headerlink" title="9.7 主从扩容缩容"></a>9.7 主从扩容缩容</h2><h3 id="9-7-1-主从扩容"><a href="#9-7-1-主从扩容" class="headerlink" title="9.7.1 主从扩容"></a>9.7.1 主从扩容</h3><p>假如因为业务量激增，需要向当前3主3从的集群中再加入1主1从两个节点。</p>
<p>步骤：</p>
<ol>
<li><p>启动2台新的容器节点</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动第7台节点</span></span><br><span class="line">docker run -d --name redis-node-7 --net host --privileged=true -v /app/redis-cluster/share/redis-node-7:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6387</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动第8台节点</span></span><br><span class="line">docker run -d --name redis-node-8 --net host --privileged=true -v /app/redis-cluster/share/redis-node-8:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6388</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入6387（节点7）容器内部</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it redis-node-7 /bin/bash</span><br></pre></td></tr></table></figure>
</li>
<li><p>将6387作为master加入集群 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">redis-cli --cluster add-node 本节点地址 要加入的集群中的其中一个节点地址</span></span><br><span class="line">redis-cli --cluster add-node 192.168.xxx.xxx:6387 192.168.xxx.xxx:6381</span><br></pre></td></tr></table></figure>
</li>
<li><p>检查当前集群状态 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster check 192.168.xxx.xxx:6381</span><br></pre></td></tr></table></figure></li>
</ol>
<p>可以发现，6371节点已经作为master加入了集群，但是该节点没有被分配槽位。 </p>
<ol start="5">
<li><p>重新分配集群的槽位 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster reshard 192.168.xxx.xxx:6381</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>redis经过槽位检查后，会提示需要分配的槽位数量：<br>例如，我们现在是4台master，我们想要给node7分配4096个槽位，这样每个节点都是4096个槽位。<br>输入<code>4096</code>后，会让输入要接收这些哈希槽的节点ID，填入node7的节点ID即可。（就是节点信息中很长的一串十六进制串）。<br>然后会提示，询问要从哪些节点中拨出一部分槽位凑足4096个分给Node7。一般选择 <code>all</code>，即将之前的3个主节点的槽位都均一些给Node7，这样可以使得每个节点的槽位数相等均衡。<br>输入<code>all</code>之后，redis会列出一个计划，内容是自动从前面的3台master中拨出一部分槽位分给Node7的槽位，需要确认一下分配的计划。<br>输入<code>yes</code>确认后，redis便会自动重新洗牌，给Node7分配槽位。</p>
</blockquote>
<p>重新分配完成后，可以进行集群信息检查，查看分配结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster check 192.168.xxx.xxx:6381</span><br></pre></td></tr></table></figure>

<p>可以发现重新洗牌后的槽位分配为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">节点1：[1365-5460]（供4096个槽位），，，分配前为[0-5460]（共5461个槽位）</span><br><span class="line">节点2：[6827-10922]（共4096个槽位），，，分配前为[5461-10922]（共5461个槽位）</span><br><span class="line">节点3：[12288-16383]（共4096个槽位），，，分配前为[10923-16383]（共5462个槽位）</span><br><span class="line"></span><br><span class="line">节点7：[0-1364],[5461-6826],[10923-12287]（共4096个槽位），从每个节点中匀出来了一部分给了节点7</span><br></pre></td></tr></table></figure>

<p>因为可能有些槽位中已经存储了<code>key</code>，完全的重新洗牌重新分配的成本过高，所以redis选择从前3个节点中匀出来一部分给节点7</p>
<p>为主节点6387分配从节点6388：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster add-node 192.168.xxx.xxx:6388 192.168.xxx.xxx:6381 --cluster-slave --cluster-master-id node7节点的十六进制编号字符串</span><br></pre></td></tr></table></figure>

<p>redis便会向6388发送消息，使其加入集群并成为6387的从节点。</p>
<p>检查集群当前状态</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster check 192.168.xxx.xxx:6381</span><br></pre></td></tr></table></figure>



<h3 id="9-7-1-主从缩容"><a href="#9-7-1-主从缩容" class="headerlink" title="9.7.1 主从缩容"></a>9.7.1 主从缩容</h3><p>假如业务高峰期过去，需要将4主4从重新缩容到3主3从。即从集群中移除node8和node7.</p>
<p>首先删除从节点6388：</p>
<ol>
<li><p>进入容器节点1 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it redis-node-1 /bin/bash</span><br></pre></td></tr></table></figure>
</li>
<li><p>检查容器状态，获取6388的节点编号 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster check 192.168.xxx.xxx:6381</span><br></pre></td></tr></table></figure>
</li>
<li><p>将6388从集群中移除 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster del-node 192.168.xxx.xxx:6388 6388节点编号</span><br></pre></td></tr></table></figure></li>
</ol>
<p>对node7重新分配哈希槽：</p>
<ol>
<li><p>对集群重新分配哈希槽 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster reshard 192.168.xxx.xxx:6381</span><br></pre></td></tr></table></figure>
</li>
<li><p>redis经过槽位检查后，会提示需要分配的槽位数量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">How many slots do you want to move (from 1 to 16384)?</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>如果我们想直接把node7的4096个哈希槽全部分给某个节点，可以直接输入4096。<br>输入<code>4096</code>后，会让输入要接收这些哈希槽的节点ID。假如我们想把这4096个槽都分给Node1，直接输入node1节点的编号即可。<br>然后会提示，询问要从哪些节点中拨出一部分槽位凑足4096个分给Node1。这里我们输入node7的节点编号，回车后输入<code>done</code>。 </p>
</blockquote>
<p>node7上面没有了哈希槽，此时便可以将node7从集群中移除。（如果node7上面有哈希槽，直接从集群中移除会报错）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster del-node 192.168.xxx.xxx:6387 node7节点编号</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">LIM</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/post/f255ffad.html">http://example.com/post/f255ffad.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">LIMの博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/docker/">docker</a></div><div class="post_share"><div class="social-share" data-image="/img/wallhaven-3z32j3.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/e26ee9ec.html" title="各种网站资源"><img class="cover" src="/img/wallhaven-p879v3.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">各种网站资源</div></div></a></div><div class="next-post pull-right"><a href="/post/dd65d9fe.html" title="leetcode题集"><img class="cover" src="/img/wallhaven-l35pw2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">leetcode题集</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/3534643.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">LIM</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Scorpios7"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Scorpios7" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到LIM的知识海洋</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-Docker%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">1. Docker概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-Dokcer%E7%AE%80%E4%BB%8B"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 Dokcer简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E4%BC%A0%E7%BB%9F%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8E%E5%AE%B9%E5%99%A8"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 传统虚拟机与容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-Docker%E8%BF%90%E8%A1%8C%E9%80%9F%E5%BA%A6%E5%BF%AB%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 Docker运行速度快的原因</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-Docker%E8%BD%AF%E4%BB%B6"><span class="toc-number">1.4.</span> <span class="toc-text">1.4 Docker软件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-Docker%E9%95%9C%E5%83%8F"><span class="toc-number">1.5.</span> <span class="toc-text">1.5 Docker镜像</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6-Docker%E4%BB%93%E5%BA%93"><span class="toc-number">1.6.</span> <span class="toc-text">1.6 Docker仓库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-7-Docker%E6%9E%B6%E6%9E%84"><span class="toc-number">1.7.</span> <span class="toc-text">1.7 Docker架构</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-Docker%E5%AE%89%E8%A3%85"><span class="toc-number">2.</span> <span class="toc-text">2. Docker安装</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-Centos%E5%AE%89%E8%A3%85Docker"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 Centos安装Docker</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E5%8D%B8%E8%BD%BD%E6%97%A7%E7%89%88%E6%9C%AC"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 卸载旧版本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E9%85%8D%E7%BD%AEyum%E8%B5%84%E6%BA%90%E5%BA%93"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 配置yum资源库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E5%AE%89%E8%A3%85Docker%E5%BC%95%E6%93%8E"><span class="toc-number">2.4.</span> <span class="toc-text">2.4 安装Docker引擎</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-%E5%90%AF%E5%8A%A8docker%E5%BC%95%E6%93%8E"><span class="toc-number">2.5.</span> <span class="toc-text">2.5 启动docker引擎</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-%E5%8D%B8%E8%BD%BDDocker"><span class="toc-number">2.6.</span> <span class="toc-text">2.6 卸载Docker</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-7-%E8%BF%90%E8%A1%8CHelloWorld%E6%B5%8B%E8%AF%95"><span class="toc-number">2.7.</span> <span class="toc-text">2.7 运行HelloWorld测试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-Docker%E4%B8%8B%E8%BD%BD%E5%8A%A0%E9%80%9F"><span class="toc-number">3.</span> <span class="toc-text">3. Docker下载加速</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">4.</span> <span class="toc-text">4. Docker常用命令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E5%90%AF%E5%8A%A8%E7%B1%BB%E5%91%BD%E4%BB%A4"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 启动类命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E5%B8%AE%E5%8A%A9%E7%B1%BB%E5%91%BD%E4%BB%A4"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 帮助类命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E9%95%9C%E5%83%8F%E5%91%BD%E4%BB%A4"><span class="toc-number">4.3.</span> <span class="toc-text">4.3 镜像命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%97%E5%87%BA%E6%9C%AC%E5%9C%B0%E4%B8%BB%E6%9C%BA%E4%B8%8A%E7%9A%84%E9%95%9C%E5%83%8F"><span class="toc-number">4.3.1.</span> <span class="toc-text">列出本地主机上的镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E4%B8%AD%E6%90%9C%E7%B4%A2%E9%95%9C%E5%83%8F"><span class="toc-number">4.3.2.</span> <span class="toc-text">在远程仓库中搜索镜像</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8B%E8%BD%BD%E9%95%9C%E5%83%8F"><span class="toc-number">4.4.</span> <span class="toc-text">下载镜像</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%8D%A0%E6%8D%AE%E7%9A%84%E7%A9%BA%E9%97%B4"><span class="toc-number">4.5.</span> <span class="toc-text">查看占据的空间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E9%95%9C%E5%83%8F"><span class="toc-number">4.6.</span> <span class="toc-text">删除镜像</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%82%AC%E9%95%9C%E5%83%8F"><span class="toc-number">4.7.</span> <span class="toc-text">虚悬镜像</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8"><span class="toc-number">4.8.</span> <span class="toc-text">命令自动补全</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E5%AE%B9%E5%99%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">5.</span> <span class="toc-text">5. 容器命令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E6%96%B0%E5%BB%BA%E5%90%AF%E5%8A%A8%E5%AE%B9%E5%99%A8"><span class="toc-number">5.1.</span> <span class="toc-text">5.1 新建启动容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E5%90%AF%E5%8A%A8%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%AE%B9%E5%99%A8"><span class="toc-number">5.2.</span> <span class="toc-text">5.2 启动交互式容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E5%90%AF%E5%8A%A8%E5%AE%88%E6%8A%A4%E5%BC%8F%E5%AE%B9%E5%99%A8"><span class="toc-number">5.3.</span> <span class="toc-text">5.3 启动守护式容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-%E5%88%97%E5%87%BA%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="toc-number">5.4.</span> <span class="toc-text">5.4 列出正在运行的容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5-%E5%AE%B9%E5%99%A8%E5%85%B6%E4%BB%96%E5%90%AF%E5%81%9C%E6%93%8D%E4%BD%9C"><span class="toc-number">5.5.</span> <span class="toc-text">5.5 容器其他启停操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-1-%E5%90%AF%E5%8A%A8%E5%B7%B2%E7%BB%8F%E5%81%9C%E6%AD%A2%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="toc-number">5.5.1.</span> <span class="toc-text">5.5.1 启动已经停止的容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-2-%E9%87%8D%E5%90%AF%E5%AE%B9%E5%99%A8"><span class="toc-number">5.5.2.</span> <span class="toc-text">5.5.2 重启容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-3-%E5%81%9C%E6%AD%A2%E5%AE%B9%E5%99%A8"><span class="toc-number">5.5.3.</span> <span class="toc-text">5.5.3 停止容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-4-%E5%BC%BA%E5%88%B6%E5%81%9C%E6%AD%A2%E5%AE%B9%E5%99%A8"><span class="toc-number">5.5.4.</span> <span class="toc-text">5.5.4 强制停止容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-5-%E5%88%A0%E9%99%A4%E5%AE%B9%E5%99%A8"><span class="toc-number">5.5.5.</span> <span class="toc-text">5.5.5 删除容器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-6-%E6%9F%A5%E7%9C%8B%E5%AE%B9%E5%99%A8%E6%97%A5%E5%BF%97"><span class="toc-number">5.6.</span> <span class="toc-text">5.6 查看容器日志</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-7-%E6%9F%A5%E7%9C%8B%E5%AE%B9%E5%99%A8%E5%86%85%E8%BF%90%E8%A1%8C%E7%9A%84%E8%BF%9B%E7%A8%8B"><span class="toc-number">5.7.</span> <span class="toc-text">5.7 查看容器内运行的进程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-8-%E6%9F%A5%E7%9C%8B%E5%AE%B9%E5%99%A8%E5%86%85%E9%83%A8%E7%BB%86%E8%8A%82"><span class="toc-number">5.8.</span> <span class="toc-text">5.8 查看容器内部细节</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-9-%E8%BF%9B%E5%85%A5%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="toc-number">5.9.</span> <span class="toc-text">5.9 进入正在运行的容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-10-%E5%AE%B9%E5%99%A8%E5%92%8C%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%96%87%E4%BB%B6%E6%8B%B7%E8%B4%9D"><span class="toc-number">5.10.</span> <span class="toc-text">5.10 容器和宿主机文件拷贝</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-11-%E5%AF%BC%E5%85%A5%E5%92%8C%E5%AF%BC%E5%87%BA%E5%AE%B9%E5%99%A8"><span class="toc-number">5.11.</span> <span class="toc-text">5.11 导入和导出容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-12-%E5%B0%86%E5%AE%B9%E5%99%A8%E7%94%9F%E6%88%90%E6%96%B0%E9%95%9C%E5%83%8F"><span class="toc-number">5.12.</span> <span class="toc-text">5.12 将容器生成新镜像</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-13-%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E5%8D%B7"><span class="toc-number">5.13.</span> <span class="toc-text">5.13 容器数据卷</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-14-%E6%89%80%E6%9C%89%E5%91%BD%E4%BB%A4%E7%A4%BA%E6%84%8F%E5%9B%BE"><span class="toc-number">5.14.</span> <span class="toc-text">5.14 所有命令示意图</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-Docker%E9%95%9C%E5%83%8F"><span class="toc-number">6.</span> <span class="toc-text">6. Docker镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E9%95%9C%E5%83%8F"><span class="toc-number">6.1.</span> <span class="toc-text">6.1 镜像</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-Docker-%E9%95%9C%E5%83%8F%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86"><span class="toc-number">6.2.</span> <span class="toc-text">6.2 Docker 镜像加载原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-1-%E8%81%94%E5%90%88%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">6.2.1.</span> <span class="toc-text">6.2.1 联合文件系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-2-bootfs%E5%92%8Crootfs"><span class="toc-number">6.2.2.</span> <span class="toc-text">6.2.2 bootfs和rootfs</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-%E9%95%9C%E5%83%8F%E5%88%86%E5%B1%82"><span class="toc-number">6.3.</span> <span class="toc-text">6.3 镜像分层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-%E9%95%9C%E5%83%8F%E5%88%86%E5%B1%82%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">6.4.</span> <span class="toc-text">6.4 镜像分层的优势</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-5-%E5%AE%B9%E5%99%A8%E5%B1%82"><span class="toc-number">6.5.</span> <span class="toc-text">6.5 容器层</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-Registry%E6%90%AD%E5%BB%BAdocker%E7%A7%81%E4%BB%93"><span class="toc-number">7.</span> <span class="toc-text">7. Registry搭建docker私仓**</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-Docker-Registry"><span class="toc-number">7.1.</span> <span class="toc-text">7.1 Docker Registry</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="toc-number">7.2.</span> <span class="toc-text">7.2 环境搭建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-%E5%90%91Registry%E7%A7%81%E4%BB%93%E4%B8%AD%E4%B8%8A%E4%BC%A0%E9%95%9C%E5%83%8F"><span class="toc-number">7.3.</span> <span class="toc-text">7.3 向Registry私仓中上传镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-1-%E9%85%8D%E7%BD%AEdocker%E5%85%81%E8%AE%B8%E6%8E%A5%E6%94%B6http%E8%AF%B7%E6%B1%82"><span class="toc-number">7.3.1.</span> <span class="toc-text">7.3.1 配置docker允许接收http请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-2-%E6%8E%A8%E9%80%81%E5%88%B0%E7%A7%81%E4%BB%93"><span class="toc-number">7.3.2.</span> <span class="toc-text">7.3.2 推送到私仓</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-Docker%E5%AE%89%E8%A3%85mysql"><span class="toc-number">8.</span> <span class="toc-text">8. Docker安装mysql</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-mysql%E5%8D%95%E6%9C%BA"><span class="toc-number">8.1.</span> <span class="toc-text">8.1 mysql单机</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-1-%E7%AE%80%E5%8D%95%E7%89%88-Mysql-5-7-%E5%AE%89%E8%A3%85"><span class="toc-number">8.1.1.</span> <span class="toc-text">8.1.1 简单版 Mysql 5.7 安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-2-%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E7%89%88-Mysql-5-7%E5%AE%89%E8%A3%85"><span class="toc-number">8.1.2.</span> <span class="toc-text">8.1.2 实际应用版 Mysql 5.7安装</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-Mysql-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%AE%89%E8%A3%85"><span class="toc-number">8.2.</span> <span class="toc-text">8.2 Mysql 主从复制安装</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-Docker%E5%AE%89%E8%A3%85Redis"><span class="toc-number">9.</span> <span class="toc-text">9. Docker安装Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1-%E5%8D%95%E6%9C%BA%E7%89%88%E5%AE%89%E8%A3%85"><span class="toc-number">9.1.</span> <span class="toc-text">9.1 单机版安装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-1-%E7%AE%80%E5%8D%95%E7%89%88-Redis"><span class="toc-number">9.1.1.</span> <span class="toc-text">9.1.1 简单版 Redis</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-2-%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E7%89%88Redis"><span class="toc-number">9.1.2.</span> <span class="toc-text">9.1.2 实际应用版Redis</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2-%E9%9B%86%E7%BE%A4%E5%AD%98%E5%82%A8%E7%AE%97%E6%B3%95"><span class="toc-number">9.2.</span> <span class="toc-text">9.2 集群存储算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-1-%E5%93%88%E5%B8%8C%E5%8F%96%E4%BD%99%E7%AE%97%E6%B3%95"><span class="toc-number">9.2.1.</span> <span class="toc-text">9.2.1 哈希取余算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-2-%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95"><span class="toc-number">9.2.2.</span> <span class="toc-text">9.2.2 一致性哈希算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-3-%E5%93%88%E5%B8%8C%E6%A7%BD%E5%88%86%E5%8C%BA"><span class="toc-number">9.2.3.</span> <span class="toc-text">9.2.3 哈希槽分区</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-3-Redis%E9%9B%86%E7%BE%A4%E5%AD%98%E5%82%A8%E7%AD%96%E7%95%A5"><span class="toc-number">9.3.</span> <span class="toc-text">9.3 Redis集群存储策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-4-3%E4%B8%BB3%E4%BB%8ERedis%E9%9B%86%E7%BE%A4"><span class="toc-number">9.4.</span> <span class="toc-text">9.4 3主3从Redis集群</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%90%AD%E5%BB%BA"><span class="toc-number">9.4.1.</span> <span class="toc-text">搭建</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-5-Redis%E9%9B%86%E7%BE%A4%E8%AF%BB%E5%86%99%E5%87%BA%E9%94%99"><span class="toc-number">9.5.</span> <span class="toc-text">9.5 Redis集群读写出错</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-6-%E9%9B%86%E7%BE%A4%E4%BF%A1%E6%81%AF%E6%A3%80%E6%9F%A5"><span class="toc-number">9.6.</span> <span class="toc-text">9.6 集群信息检查</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-7-%E4%B8%BB%E4%BB%8E%E6%89%A9%E5%AE%B9%E7%BC%A9%E5%AE%B9"><span class="toc-number">9.7.</span> <span class="toc-text">9.7 主从扩容缩容</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-7-1-%E4%B8%BB%E4%BB%8E%E6%89%A9%E5%AE%B9"><span class="toc-number">9.7.1.</span> <span class="toc-text">9.7.1 主从扩容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-7-1-%E4%B8%BB%E4%BB%8E%E7%BC%A9%E5%AE%B9"><span class="toc-number">9.7.2.</span> <span class="toc-text">9.7.1 主从缩容</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/d2f8097a.html" title="Redis数据类型详解"><img src="/img/wallhaven-x8kkd3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis数据类型详解"/></a><div class="content"><a class="title" href="/post/d2f8097a.html" title="Redis数据类型详解">Redis数据类型详解</a><time datetime="2023-02-26T12:32:06.000Z" title="发表于 2023-02-26 20:32:06">2023-02-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/fd42e092.html" title="什么是消息队列"><img src="/img/wallhaven-yxm6z7.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="什么是消息队列"/></a><div class="content"><a class="title" href="/post/fd42e092.html" title="什么是消息队列">什么是消息队列</a><time datetime="2023-02-26T07:28:28.000Z" title="发表于 2023-02-26 15:28:28">2023-02-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/1f34c3f3.html" title="Redis三种常用的缓存读写策略"><img src="/img/wallhaven-r2o1w1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis三种常用的缓存读写策略"/></a><div class="content"><a class="title" href="/post/1f34c3f3.html" title="Redis三种常用的缓存读写策略">Redis三种常用的缓存读写策略</a><time datetime="2023-02-25T12:57:05.000Z" title="发表于 2023-02-25 20:57:05">2023-02-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/9a0369ec.html" title="布隆过滤器"><img src="/img/wallhaven-6ojj2w.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="布隆过滤器"/></a><div class="content"><a class="title" href="/post/9a0369ec.html" title="布隆过滤器">布隆过滤器</a><time datetime="2023-02-25T12:01:05.000Z" title="发表于 2023-02-25 20:01:05">2023-02-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/8fc8c009.html" title="HashMap的遍历方式与性能分析"><img src="/img/wallhaven-6q6e9l.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="HashMap的遍历方式与性能分析"/></a><div class="content"><a class="title" href="/post/8fc8c009.html" title="HashMap的遍历方式与性能分析">HashMap的遍历方式与性能分析</a><time datetime="2023-02-24T03:01:42.000Z" title="发表于 2023-02-24 11:01:42">2023-02-24</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 By LIM</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>